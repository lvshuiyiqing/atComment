<carlos home directory>@horseradish:~$ cd temp-eclipse/jrandoop/
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ ls
CVS  ant-macros.xml  bin  build.xml  command.txt  dist	doc  lib  src  tests
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ ant export
Buildfile: build.xml

init:

clean:

dirtybuild:
    [mkdir] Created dir: /afs/csail.mit.edu/u/c/<carlos home directory>/temp-eclipse/jrandoop/testclasses-bin
     [echo] compiling
    [javac] Compiling 19 source files to /afs/csail.mit.edu/u/c/<carlos home directory>/temp-eclipse/jrandoop/bin
     [echo] copy resource files to bin directory

build:

export:
   [delete] Deleting: /afs/csail.mit.edu/u/c/<carlos home directory>/temp-eclipse/jrandoop/dist/randoop.jar
      [jar] Building jar: /afs/csail.mit.edu/u/c/<carlos home directory>/temp-eclipse/jrandoop/dist/randoop.jar

BUILD SUCCESSFUL
Total time: 32 seconds
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ ls *.xml
ant-macros.xml	build.xml
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ ls
CVS		bin	   command.txt	doc  src	      tests
ant-macros.xml	build.xml  dist		lib  testclasses-bin
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main
Randoop for Java version 0.1.

Randoop  is a command-line tool that creates unit tests for Java. It supports
various commands, documented below. For more high-level
documentation please refer to the online manual at 
http://people.csail.mit.edu/<carlos home directory>/randoop/

Type `help' followed by a command name to see documentation.

Commands:

genfailures -- Attempts to generate contract-violating unit tests for
        a set of classes.

genregressions -- Attempts to generate regression unit tests for a set
        of classes.

help -- Displays a help message for a given command.


<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive
TIME=100,SEQS=1000000
You must specify some classes to test. Use the `--classlist' or `--testclass' options.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
.....................................................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
...............................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@18e3e60]}
Throwable thrown while handling command:java.lang.RuntimeException: java.io.IOException: Stream closed
java.lang.RuntimeException: java.io.IOException: Stream closed
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:350)
	at randoop.sequence.generators.NaiveRandomGenerator.generateSequences(NaiveRandomGenerator.java:230)
	at randoop.main.commands.GenInputsNaive.handle(GenInputsNaive.java:79)
	at randoop.main.Main.nonStaticMain(Main.java:88)
	at randoop.main.Main.main(Main.java:50)
Caused by: java.io.IOException: Stream closed
	at java.io.BufferedInputStream.getBufIfOpen(BufferedInputStream.java:145)
	at java.io.BufferedInputStream.read(BufferedInputStream.java:308)
	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)
	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)
	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)
	at java.io.InputStreamReader.read(InputStreamReader.java:167)
	at java.io.BufferedReader.fill(BufferedReader.java:136)
	at java.io.BufferedReader.readLine(BufferedReader.java:299)
	at java.io.BufferedReader.readLine(BufferedReader.java:362)
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:347)
	... 4 more
Randoop failed.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}
0

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41]}
Throwable thrown while handling command:java.lang.RuntimeException: java.io.IOException: Stream closed
java.lang.RuntimeException: java.io.IOException: Stream closed
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:351)
	at randoop.sequence.generators.NaiveRandomGenerator.generateSequences(NaiveRandomGenerator.java:230)
	at randoop.main.commands.GenInputsNaive.handle(GenInputsNaive.java:79)
	at randoop.main.Main.nonStaticMain(Main.java:88)
	at randoop.main.Main.main(Main.java:50)
Caused by: java.io.IOException: Stream closed
	at java.io.BufferedInputStream.getInIfOpen(BufferedInputStream.java:134)
	at java.io.BufferedInputStream.available(BufferedInputStream.java:381)
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:347)
	... 4 more
Randoop failed.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}
0

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41]}
Throwable thrown while handling command:java.lang.RuntimeException: java.io.IOException: Stream closed
java.lang.RuntimeException: java.io.IOException: Stream closed
	at randoop.sequence.generators.NaiveRandomGenerator.readLine(NaiveRandomGenerator.java:406)
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:345)
	at randoop.sequence.generators.NaiveRandomGenerator.generateSequences(NaiveRandomGenerator.java:230)
	at randoop.main.commands.GenInputsNaive.handle(GenInputsNaive.java:79)
	at randoop.main.Main.nonStaticMain(Main.java:88)
	at randoop.main.Main.main(Main.java:50)
Caused by: java.io.IOException: Stream closed
	at java.io.BufferedInputStream.getInIfOpen(BufferedInputStream.java:134)
	at java.io.BufferedInputStream.available(BufferedInputStream.java:381)
	at randoop.sequence.generators.NaiveRandomGenerator.readLine(NaiveRandomGenerator.java:402)
	... 5 more
Randoop failed.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b, randoop.util.TypeToObjectMap$HotPotato@1e87719], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c, randoop.util.TypeToObjectMap$HotPotato@c791b9], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b, randoop.util.TypeToObjectMap$HotPotato@1e87719], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c, randoop.util.TypeToObjectMap$HotPotato@c791b9], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b, randoop.util.TypeToObjectMap$HotPotato@1e87719], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb], class java.util.TreeSet=[randoop.util.TypeToObjectMap$HotPotato@1bbd23f]}

.@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf]}

@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf], class java.util.Collections$SingletonSet=[randoop.util.TypeToObjectMap$HotPotato@1e57e8f]}

@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf], class java.util.Collections$SingletonSet=[randoop.util.TypeToObjectMap$HotPotato@1e57e8f], class java.util.TreeSet=[randoop.util.TypeToObjectMap$HotPotato@bad8a8]}

@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf], class java.util.Collections$SingletonSet=[randoop.util.TypeToObjectMap$HotPotato@1e57e8f], class java.util.TreeSet=[randoop.util.TypeToObjectMap$HotPotato@bad8a8], class java.util.Collections$UnmodifiableSortedSet=[randoop.util.TypeToObjectMap$HotPotato@b9e45a]}

<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}

<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
.........BUG!
....BUG!
....BUG!
..................BUG!
....BUG!
.....BUG!
........BUG!
.......BUG!
...BUG!
.......BUG!
...........
....BUG!
............BUG!
...BUG!
.............BUG!
....BUG!
...BUG!
.....BUG!
......BUG!
..<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
.........1
....2
....1
..................1
....1
.....1
........2
.......1
...1
.......1
...........
....1
............1
...1
.............2
....1
...1
.....1
......2
...1
.......2
.......2
..1
.....1
......
.1
.......2
.......1
........<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=100 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
2
...4
.1
..1
...2
.6
..2
....2
.1
.2
.2
.1
.2
......2
.4
..1
.1
...1
..1
.2
....2
.1
.2
.2
..1
.4
........1
...1
..1
..<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=100 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.EqualsNotReflexive
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
......randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
...randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
........randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
...
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
.<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=1000 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
.<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist= bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2
ERROR while parsing command-line arguments (will exit): Unrecognized arguments: [bin/joe/test/resources/java.util.classlist.java1.6.txt]
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
java.util.NoSuchElementException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
.java.util.TooManyListenersException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = [[(this Collection)]]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.TooManyListenersException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = [[(this Collection)]]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
..java.util.EmptyStackException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
.java.util.UnknownFormatFlagsException: Flags = java.util.InputMismatchException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = java.util.InputMismatchException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = java.util.InputMismatchException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.InputMismatchException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at randoop.reflectionexecution.MethodReflectionCode.runReflectionCodeRaw(MethodReflectionCode.java:73)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
.<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
......randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.ToStringThrowsException
......randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=10 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................................................................
.....................................................................randoop.contract.unary.EqualsNotReflexive
...........
................................................................................
................................................................................
................................................................................
.............................................................................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=3 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
..<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=30 --randomseed=3 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................randoop.contract.unary.EqualsNotReflexive
..................................randoop.contract.unary.EqualsNotReflexive
...........randoop.contract.unary.EqualsNotReflexive
...
..............................................randoop.contract.unary.EqualsNotReflexive
.....randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
.......................randoop.contract.unary.EqualsNotReflexive
randoop.contract.binary.EqualsNotSymmetric
randoop.contract.binary.EqualsNotSymmetric
randoop.contract.binary.EqualsNotSymmetric
randoop.contract.binary.EqualsNotSymmetric
......
.............................................................randoop.contract.unary.EqualsNotReflexive
.......randoop.contract.unary.EqualsNotReflexive
............
.................................randoop.contract.unary.EqualsNotReflexive
........................randoop.contract.unary.EqualsNotReflexive
.....randoop.contract.unary.EqualsNotReflexive
................randoop.contract.unary.EqualsNotReflexive
..
.............................randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
..............................randoop.contract.unary.EqualsNotReflexive
.....................
...........................randoop.contract.unary.EqualsNotReflexive
.....randoop.contract.unary.EqualsNotReflexive
.......randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.EqualsNotReflexive
...........<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt --usethreads
ERROR while parsing command-line arguments (will exit): unknown argument '--usethreads'
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................................................................
.............................................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
............<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
..
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ <carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=50 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
.............................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
...
................................................................................
...............................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=50 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
.............................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
...
........................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=50 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
.............................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
...
................................................................................
.......................................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ javac Temp.java 
Note: Temp.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java Temp
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 0,Size: 0
	at java.util.SubList.rangeCheck(AbstractList.java:746)
	at java.util.SubList.remove(AbstractList.java:640)
	at Temp.main(Temp.java:17)
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=10 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.Collections$CopiesList)
***
java.util.Random var0 = new java.util.Random();
java.util.BitSet var1 = new java.util.BitSet();
int var2 = var1.cardinality();
int var3 = var0.nextInt();
java.util.TreeSet var4 = new java.util.TreeSet();
java.util.List var5 = java.util.Collections.nCopies((int)var3, (java.lang.Object)var1);

***
................
................................................................................
................................................................................
................................................................................
..............................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.Collections$CopiesList)
***
java.util.Random var0 = new java.util.Random();
java.util.NoSuchElementException var1 = new java.util.NoSuchElementException();
java.util.BitSet var2 = new java.util.BitSet();
java.lang.Throwable var3 = var1.getCause();
int var4 = var0.nextInt();
var2.or((java.util.BitSet)var2);
java.lang.StackTraceElement[] var6 = var1.getStackTrace();
java.util.List var7 = java.util.Collections.nCopies((int)var4, (java.lang.Object)var4);

***
..................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
...........................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.Collections$CopiesList)
***
java.util.Observable var0 = new java.util.Observable();
java.util.EmptyStackException var1 = new java.util.EmptyStackException();
java.util.Random var2 = new java.util.Random();
int var3 = var2.nextInt();
java.util.Set var4 = java.util.Collections.emptySet();
boolean var5 = var4.remove((java.lang.Object)var2);
java.util.List var6 = java.util.Collections.nCopies((int)var3, (java.lang.Object)var3);

***
.....................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
..........................................................................<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ javac Temp.java
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java Temp
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java Temp
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java Temp
Exception in thread "main" java.lang.IllegalArgumentException: List length = -112603528
	at java.util.Collections.nCopies(Collections.java:3203)
	at Temp.main(Temp.java:10)
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ javac Temp.java
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java Temp
Exception in thread "main" java.lang.IllegalArgumentException: List length = -1186097780
	at java.util.Collections.nCopies(Collections.java:3203)
	at Temp.main(Temp.java:10)
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ java Temp
1649146609
1649146609
<carlos home directory>@horseradish:~/temp-eclipse/jrandoop$ 
