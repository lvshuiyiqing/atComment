Types of problems

  - indirect-call

    This occurs when a method could be called directly but isn't.  Parameters
    that we could otherwise trace are not part of the test sequence

  - collection-too-small

    This occur when a method is never called with a big enough collection
    in order for certain code to occur.  If there were an explicit comparison
    to size, we might be able to figure this out, but if there is not 
    (as occurs in mergeSort), its not clear what we could do to figure this
    out.

    Its possible that we could figure out that this was related to size if
    we included comparisons in the dataflow.  The list is iterated through
    with an index:

        for (int ii = 0; ii < size; ii++)

    If we note that ii was compared to size, we could infer that changing
    size would make a difference.  Note that the comparison to size is
    NOT the frontier branch, ii is used in a nested loop.

  - collection-too-similar

    A similar problem to collection-too-small that occurs because the only
    large collections we get have all of the same value in them.

  - compare-uninstrumented

    Both implementing the Comparable interface or creating a separate
    Comparator result in code that is not instrumented.  The instrumentation
    see these as jdk classes and doesn't realize that there is an instrumented
    implementation behind them.

    It should be possible to do this.  When a call is made via a JDK interface,
    we should be able to ask something of the object to see if it is
    instrumented.  If so, we should be able to call the instrumented routine.
    Unfortunately, the call will have to be via reflection or we'll have
    to create our own matching interfaces (which shouldn't be too bad for
    the popular ones).

  - equals

    We  can take advantage of the contract for equals by exporing some
    obvious equals specific state.  For example, we should try passing
    null, a different type object, the same type object, the exact same
    object, an object created by the same sequence etc to equals.  This
    should exercise much of the code.

  - indirect-field

    The comparison is to a field (such as size) that is set in an indirect
    fashion (eg, ArrayList.add() will increment size).

  - instance-of

    The frontier branch contains an instanceof check.  We should return
    this information to Randoop

  - break-return-cf

    A while or for loop with nested breaks or returns may never take
    the false branch (ie, the loop may never finish).  The pertinent 
    information is really on the if statements that control the break
    and return and not the while/for loop itself.  

    It seems like we could find such nested if statements and associate
    them with the frontier branch.

  - control-flow-boolean

    A boolean result is returned from an if stmt.  For example

      return x== y || x > y

    Since the boolean is created by control flow, it will not contain
    any informatin from the actual comparisons.  This can probably be
    fixed by associated local control flow (in the same method) with
    any constants (such as true/false) that are pushed on the stack.

  - hash

    The branch is comparing hash codes.  It should be possible to make this
    work correctly in at least some circumstances.  A call to an instrumented
    version of hash should end up with the hash code dependent on each of
    the values within the object.  An uninstrumented hash will do nothing.
    Since most calls to hash will be via object, most will appear to be
    uninstrumented.  We should change these in a manner similar to equals
    so that the object itself is associated with the hash value.  We would
    then see dataflow information for all hash values.

  - bug

    Looks like DF information should have been returned and there
    is a bug of some sort.

  - no-df

    There is no reasonable data-flow data to return.  For example,
    a comparison with the size of a bucket list in a hash table.  This
    isn't even an indirect  field (it isn't going to increase with each
    put), so there isn't much information to say here.  Other than building
    bigger collections will execute more code.

START RECORD
BRANCH 
classname=java2.util2.ArrayList,methodname=ensureCapacity,line=167,id=3,direction=false
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : short:10 : 
var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
var5 =  prim : long:1 : 
var6 =  prim : java.lang.Object:null : 
var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
var9 =  method : java2.util2.Collections.list(java2.util2.Enumeration) : var8 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Short var1 = new java.lang.Short((short)10);
java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
java.lang.Long var5 = new java.lang.Long((long)1);
java.lang.Object var6 = null;
boolean var7 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var5, (java.lang.Object)var6);
java2.util2.Enumeration var8 = java2.util2.Collections.enumeration((java2.util2.Collection)var4);
java2.util2.ArrayList var9 = java2.util2.Collections.list((java2.util2.Enumeration)var8);

Variables: []
      /**
       * Increases the capacity of this <tt>ArrayList</tt> instance, if
       * necessary, to ensure  that it can hold at least the number of elements
       * specified by the minimum capacity argument. 
       *
       * @param   minCapacity   the desired minimum capacity.
       */
      public void ensureCapacity(int minCapacity) {
  	modCount++;
  	int oldCapacity = elementData.length;
  	if (minCapacity > oldCapacity) {
  	    Object oldData[] = elementData;
  	    int newCapacity = (oldCapacity * 3)/2 + 1;
>>    	    if (newCapacity < minCapacity)
  		newCapacity = minCapacity;
  	    elementData = new Object[newCapacity];
  	    System.arraycopy(oldData, 0, elementData, 0, size);
  	}
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: indirect-call

=========================================================

START RECORD
BRANCH 
classname=java2.util2.Arrays,methodname=mergeSort,line=1151,id=103,direction=false
SEQUENCE
var0 =  prim : long:-1 : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  method : java2.util2.Collections.sort(java2.util2.List) : var1 

END RECORD

As source code:
java.lang.Long var0 = new java.lang.Long((long)-1);
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java2.util2.Collections.sort((java2.util2.List)var1);

Variables: []
      /**
       * Src is the source array that starts at index 0
       * Dest is the (possibly larger) array destination with a possible offset
       * low is the index in dest to start sorting
       * high is the end index in dest to end sorting
       * off is the offset to generate corresponding low, high in src
       */
      private static void mergeSort(Object src[], Object dest[],
                                    int low, int high, int off) {
  	int length = high - low;
  
  	// Insertion sort on smallest arrays
          if (length < INSERTIONSORT_THRESHOLD) {
              for (int i=low; i<high; i++)
>>                for (int j=i; j>low &&
                   ((Comparable)dest[j-1]).compareTo((Comparable)dest[j])>0; j--)
                      swap(dest, j, j-1);
              return;
          }
  
          // Recursively sort halves of dest into src
          int destLow  = low;
          int destHigh = high;
          low  += off;
          high += off;
          int mid = (low + high) >> 1;
          mergeSort(dest, src, low, mid, -off);
          mergeSort(dest, src, mid, high, -off);
  
          // If list is already sorted, just copy from src to dest.  This is an
          // optimization that results in faster sorts for nearly ordered lists.
          if (((Comparable)src[mid-1]).compareTo((Comparable)src[mid]) <= 0) {
              System.arraycopy(src, low, dest, destLow, length);
              return;
          }
  
          // Merge sorted halves (now in src) into dest
          for(int i = destLow, p = low, q = mid; i < destHigh; i++) {
              if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0)
                  dest[i] = src[p++];
              else
                  dest[i] = src[q++];
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small

===================================================

START RECORD
BRANCH 
classname=java2.util2.Arrays,methodname=mergeSort,line=1278,id=111,direction=false
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  method : java2.util2.Collections.reverseOrder() : 
var3 =  method : java2.util2.Collections.sort(java2.util2.List,java2.util2.Comparator) : var1 var2 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java2.util2.Comparator var2 = java2.util2.Collections.reverseOrder();
java2.util2.Collections.sort((java2.util2.List)var1, (java2.util2.Comparator)var2);

Variables: []
      /**
       * Src is the source array that starts at index 0
       * Dest is the (possibly larger) array destination with a possible offset
       * low is the index in dest to start sorting
       * high is the end index in dest to end sorting
       * off is the offset into src corresponding to low in dest
       */
      private static void mergeSort(Object src[], Object dest[],
                                    int low, int high, int off, Comparator c) {
  	int length = high - low;
  
  	// Insertion sort on smallest arrays
  	if (length < INSERTIONSORT_THRESHOLD) {
  	    for (int i=low; i<high; i++)
>>		for (int j=i; j>low && c.compare(dest[j-1], dest[j])>0; j--)
  		    swap(dest, j, j-1);
  	    return;
  	}
  
          // Recursively sort halves of dest into src
          int destLow  = low;
          int destHigh = high;
          low  += off;
          high += off;
          int mid = (low + high) >> 1;
          mergeSort(dest, src, low, mid, -off, c);
          mergeSort(dest, src, mid, high, -off, c);
  
          // If list is already sorted, just copy from src to dest.  This is an
          // optimization that results in faster sorts for nearly ordered lists.
          if (c.compare(src[mid-1], src[mid]) <= 0) {
             System.arraycopy(src, low, dest, destLow, length);
             return;
          }
  
          // Merge sorted halves (now in src) into dest
          for(int i = destLow, p = low, q = mid; i < destHigh; i++) {
              if (q >= high || p < mid && c.compare(src[p], src[q]) <= 0)
                  dest[i] = src[p++];
              else
                  dest[i] = src[q++];
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small

=============================================

START RECORD
BRANCH 
classname=java2.util2.Arrays,methodname=mergeSort,line=1294,id=112,direction=true
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : float:100.0 : 
var2 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var1 
var3 =  method : java2.util2.Collections.reverseOrder() : 
var4 =  method : java2.util2.Collections.sort(java2.util2.List,java2.util2.Comparator) : var2 var3 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Float var1 = new java.lang.Float((float)100.0);
java2.util2.List var2 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var1);
java2.util2.Comparator var3 = java2.util2.Collections.reverseOrder();
java2.util2.Collections.sort((java2.util2.List)var2, (java2.util2.Comparator)var3);

Variables: []
      /**
       * Src is the source array that starts at index 0
       * Dest is the (possibly larger) array destination with a possible offset
       * low is the index in dest to start sorting
       * high is the end index in dest to end sorting
       * off is the offset into src corresponding to low in dest
       */
      private static void mergeSort(Object src[], Object dest[],
                                    int low, int high, int off, Comparator c) {
  	int length = high - low;
  
  	// Insertion sort on smallest arrays
  	if (length < INSERTIONSORT_THRESHOLD) {
  	    for (int i=low; i<high; i++)
  		for (int j=i; j>low && c.compare(dest[j-1], dest[j])>0; j--)
  		    swap(dest, j, j-1);
  	    return;
  	}
  
          // Recursively sort halves of dest into src
          int destLow  = low;
          int destHigh = high;
          low  += off;
          high += off;
          int mid = (low + high) >> 1;
          mergeSort(dest, src, low, mid, -off, c);
          mergeSort(dest, src, mid, high, -off, c);
  
          // If list is already sorted, just copy from src to dest.  This is an
          // optimization that results in faster sorts for nearly ordered lists.
>>        if (c.compare(src[mid-1], src[mid]) <= 0) {
             System.arraycopy(src, low, dest, destLow, length);
             return;
          }
  
          // Merge sorted halves (now in src) into dest
          for(int i = destLow, p = low, q = mid; i < destHigh; i++) {
              if (q >= high || p < mid && c.compare(src[p], src[q]) <= 0)
                  dest[i] = src[p++];
              else
                  dest[i] = src[q++];
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: compare-uninstrumented

===================================================

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=copy,line=520,id=29,direction=true
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var2 
var4 =  method : java2.util2.Collections.copy(java2.util2.List,java2.util2.List) : var1 var3 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Object var2 = null;
java2.util2.List var3 = java2.util2.Collections.singletonList((java.lang.Object)var2);
java2.util2.Collections.copy((java2.util2.List)var1, (java2.util2.List)var3);

Variables: []
      /**
       * Copies all of the elements from one list into another.  After the
       * operation, the index of each copied element in the destination list
       * will be identical to its index in the source list.  The destination
       * list must be at least as long as the source list.  If it is longer, the
       * remaining elements in the destination list are unaffected. <p>
       *
       * This method runs in linear time.
       *
       * @param  dest The destination list.
       * @param  src The source list.
       * @throws IndexOutOfBoundsException if the destination list is too small
       *         to contain the entire source List.
       * @throws UnsupportedOperationException if the destination list's
       *         list-iterator does not support the <tt>set</tt> operation.
       */
      public static void copy(List dest, List src) {
          int srcSize = src.size();
          if (srcSize > dest.size())
              throw new IndexOutOfBoundsException("Source does not fit in dest");
  
>>        if (srcSize < COPY_THRESHOLD ||
              (src instanceof RandomAccess && dest instanceof RandomAccess)) {
              for (int i=0; i<srcSize; i++)
                  dest.set(i, src.get(i));
          } else {
              ListIterator di=dest.listIterator(), si=src.listIterator();
              for (int i=0; i<srcSize; i++) {
                  di.next();
                  di.set(si.next());
              }
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: indirect-field

============================================================

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=fill,line=487,id=25,direction=true
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.Collections.fill(java2.util2.List,java.lang.Object) : var1 var2 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Object var2 = null;
java2.util2.Collections.fill((java2.util2.List)var1, (java.lang.Object)var2);

Variables: []
      /**
       * Replaces all of the elements of the specified list with the specified
       * element. <p>
       *
       * This method runs in linear time.
       *
       * @param  list the list to be filled with the specified element.
       * @param  obj The element with which to fill the specified list.
       * @throws UnsupportedOperationException if the specified list or its
       *	       list-iterator does not support the <tt>set</tt> operation.
       */
      public static void fill(List list, Object obj) {
          int size = list.size();
  
>>        if (size < FILL_THRESHOLD || list instanceof RandomAccess) {
              for (int i=0; i<size; i++)
                  list.set(i, obj);
          } else {
              ListIterator itr = list.listIterator();
              for (int i=0; i<size; i++) {
                  itr.next();
                  itr.set(obj);
              }
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: indirect-field instance-of

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=indexOfSubList,line=856,id=62,direction=true
SEQUENCE
var0 =  prim : long:-1 : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : double:10.0 : 
var3 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var2 
var4 =  method : java2.util2.Collections.indexOfSubList(java2.util2.List,java2.util2.List) : var1 var3 

END RECORD

As source code:
java.lang.Long var0 = new java.lang.Long((long)-1);
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Double var2 = new java.lang.Double((double)10.0);
java2.util2.List var3 = java2.util2.Collections.singletonList((java.lang.Object)var2);
int var4 = java2.util2.Collections.indexOfSubList((java2.util2.List)var1, (java2.util2.List)var3);

Variables: []
      /**
       * Returns the starting position of the first occurrence of the specified
       * target list within the specified source list, or -1 if there is no
       * such occurrence.  More formally, returns the the lowest index <tt>i</tt>
       * such that <tt>source.subList(i, i+target.size()).equals(target)</tt>,
       * or -1 if there is no such index.  (Returns -1 if
       * <tt>target.size() > source.size()</tt>.)
       *
       * <p>This implementation uses the "brute force" technique of scanning
       * over the source list, looking for a match with the target at each
       * location in turn.
       *
       * @param source the list in which to search for the first occurrence
       *        of <tt>target</tt>.
       * @param target the list to search for as a subList of <tt>source</tt>.
       * @return the starting position of the first occurrence of the specified
       *         target list within the specified source list, or -1 if there
       *         is no such occurrence.
       * @since  1.4
       */
      public static int indexOfSubList(List source, List target) {
          int sourceSize = source.size();
          int targetSize = target.size();
          int maxCandidate = sourceSize - targetSize;
  
>>        if (sourceSize < INDEXOFSUBLIST_THRESHOLD ||
              (source instanceof RandomAccess&&target instanceof RandomAccess)) {
          nextCand:
              for (int candidate = 0; candidate <= maxCandidate; candidate++) {
                  for (int i=0, j=candidate; i<targetSize; i++, j++)
                      if (!eq(target.get(i), source.get(j)))
                          continue nextCand;  // Element mismatch, try next cand
                  return candidate;  // All elements of candidate matched target
              }
          } else {  // Iterator version of above algorithm
              ListIterator si = source.listIterator();
          nextCand:
              for (int candidate = 0; candidate <= maxCandidate; candidate++) {
                  ListIterator ti = target.listIterator();
                  for (int i=0; i<targetSize; i++) {
                      if (!eq(ti.next(), si.next())) {
                          // Back up source iterator to next candidate
                          for (int j=0; j<i; j++)
                              si.previous();
                          continue nextCand;
                      }
                  }
                  return candidate;
              }
          }
          return -1;  // No candidate matched the target
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: indirect-field instance-of

==============================================


START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=indexOfSubList,line=860,id=64,direction=true
SEQUENCE
var0 =  prim : long:-1 : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : double:10.0 : 
var3 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var2 
var4 =  method : java2.util2.Collections.indexOfSubList(java2.util2.List,java2.util2.List) : var1 var3 

END RECORD

As source code:
java.lang.Long var0 = new java.lang.Long((long)-1);
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Double var2 = new java.lang.Double((double)10.0);
java2.util2.List var3 = java2.util2.Collections.singletonList((java.lang.Object)var2);
int var4 = java2.util2.Collections.indexOfSubList((java2.util2.List)var1, (java2.util2.List)var3);

Variables: []
      /**
       * Returns the starting position of the first occurrence of the specified
       * target list within the specified source list, or -1 if there is no
       * such occurrence.  More formally, returns the the lowest index <tt>i</tt>
       * such that <tt>source.subList(i, i+target.size()).equals(target)</tt>,
       * or -1 if there is no such index.  (Returns -1 if
       * <tt>target.size() > source.size()</tt>.)
       *
       * <p>This implementation uses the "brute force" technique of scanning
       * over the source list, looking for a match with the target at each
       * location in turn.
       *
       * @param source the list in which to search for the first occurrence
       *        of <tt>target</tt>.
       * @param target the list to search for as a subList of <tt>source</tt>.
       * @return the starting position of the first occurrence of the specified
       *         target list within the specified source list, or -1 if there
       *         is no such occurrence.
       * @since  1.4
       */
      public static int indexOfSubList(List source, List target) {
          int sourceSize = source.size();
          int targetSize = target.size();
          int maxCandidate = sourceSize - targetSize;
  
          if (sourceSize < INDEXOFSUBLIST_THRESHOLD ||
              (source instanceof RandomAccess&&target instanceof RandomAccess)) {
          nextCand:
              for (int candidate = 0; candidate <= maxCandidate; candidate++) {
>>                for (int i=0, j=candidate; i<targetSize; i++, j++)
                      if (!eq(target.get(i), source.get(j)))
                          continue nextCand;  // Element mismatch, try next cand
                  return candidate;  // All elements of candidate matched target
              }
          } else {  // Iterator version of above algorithm
              ListIterator si = source.listIterator();
          nextCand:
              for (int candidate = 0; candidate <= maxCandidate; candidate++) {
                  ListIterator ti = target.listIterator();
                  for (int i=0; i<targetSize; i++) {
                      if (!eq(ti.next(), si.next())) {
                          // Back up source iterator to next candidate
                          for (int j=0; j<i; j++)
                              si.previous();
                          continue nextCand;
                      }
                  }
                  return candidate;
              }
          }
          return -1;  // No candidate matched the target
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small

====================================================

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=lastIndexOfSubList,line=909,id=70,direction=true
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var2 
var4 =  method : java2.util2.Collections.lastIndexOfSubList(java2.util2.List,java2.util2.List) : var1 var3 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Object var2 = null;
java2.util2.List var3 = java2.util2.Collections.singletonList((java.lang.Object)var2);
int var4 = java2.util2.Collections.lastIndexOfSubList((java2.util2.List)var1, (java2.util2.List)var3);

Variables: []
      /**
       * Returns the starting position of the last occurrence of the specified
       * target list within the specified source list, or -1 if there is no such
       * occurrence.  More formally, returns the the highest index <tt>i</tt>
       * such that <tt>source.subList(i, i+target.size()).equals(target)</tt>,
       * or -1 if there is no such index.  (Returns -1 if
       * <tt>target.size() > source.size()</tt>.)
       *
       * <p>This implementation uses the "brute force" technique of iterating
       * over the source list, looking for a match with the target at each
       * location in turn.
       *
       * @param source the list in which to search for the last occurrence
       *        of <tt>target</tt>.
       * @param target the list to search for as a subList of <tt>source</tt>.
       * @return the starting position of the last occurrence of the specified
       *         target list within the specified source list, or -1 if there
       *         is no such occurrence.
       * @since  1.4
       */
      public static int lastIndexOfSubList(List source, List target) {
          int sourceSize = source.size();
          int targetSize = target.size();
          int maxCandidate = sourceSize - targetSize;
  
>>        if (sourceSize < INDEXOFSUBLIST_THRESHOLD ||
              source instanceof RandomAccess) {   // Index access version
          nextCand:
              for (int candidate = maxCandidate; candidate >= 0; candidate--) {
                  for (int i=0, j=candidate; i<targetSize; i++, j++)
                      if (!eq(target.get(i), source.get(j)))
                          continue nextCand;  // Element mismatch, try next cand
                  return candidate;  // All elements of candidate matched target
              }
          } else {  // Iterator version of above algorithm
              if (maxCandidate < 0)
                  return -1;
              ListIterator si = source.listIterator(maxCandidate);
          nextCand:
              for (int candidate = maxCandidate; candidate >= 0; candidate--) {
                  ListIterator ti = target.listIterator();
                  for (int i=0; i<targetSize; i++) {
                      if (!eq(ti.next(), si.next())) {
                          if (candidate != 0) {
                              // Back up source iterator to next candidate
                              for (int j=0; j<=i+1; j++)
                                  si.previous();
                          }
                          continue nextCand;
                      }
                  }
                  return candidate;
              }
          }
          return -1;  // No candidate matched the target
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small indirect-field

===============================================

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=min,line=560,id=33,direction=false
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : float:100.0 : 
var2 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var1 
var3 =  method : java2.util2.Collections.min(java2.util2.Collection) : var2 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Float var1 = new java.lang.Float((float)100.0);
java2.util2.List var2 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var1);
java.lang.Object var3 = java2.util2.Collections.min((java2.util2.Collection)var2);

Variables: []
      /**
       * Returns the minimum element of the given collection, according to the
       * <i>natural ordering</i> of its elements.  All elements in the
       * collection must implement the <tt>Comparable</tt> interface.
       * Furthermore, all elements in the collection must be <i>mutually
       * comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a
       * <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
       * <tt>e2</tt> in the collection).<p>
       *
       * This method iterates over the entire collection, hence it requires
       * time proportional to the size of the collection.
       *
       * @param  coll the collection whose minimum element is to be determined.
       * @return the minimum element of the given collection, according
       *         to the <i>natural ordering</i> of its elements.
       * @throws ClassCastException if the collection contains elements that are
       *	       not <i>mutually comparable</i> (for example, strings and
       *	       integers).
       * @throws NoSuchElementException if the collection is empty.
       * @see Comparable
       */
      public static Object min(Collection coll) {
  	Iterator i = coll.iterator();
  	Comparable candidate = (Comparable)(i.next());
  
          while(i.hasNext()) {
  	    Comparable next = (Comparable)(i.next());
>>	    if (next.compareTo(candidate) < 0)
  		candidate = next;
  	}
  	return candidate;
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-similar compare-uninstrumented

=================================================

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=replaceAll,line=794,id=51,direction=true
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : char:20 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var1 var2 var3 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Character var2 = new java.lang.Character((char)' ');
java.lang.Object var3 = null;
boolean var4 = java2.util2.Collections.replaceAll((java2.util2.List)var1, (java.lang.Object)var2, (java.lang.Object)var3);

Variables: []
      /**
       * Replaces all occurrences of one specified value in a list with another.
       * More formally, replaces with <tt>newVal</tt> each element <tt>e</tt>
       * in <tt>list</tt> such that
       * <tt>(oldVal==null ? e==null : oldVal.equals(e))</tt>.
       * (This method has no effect on the size of the list.)
       *
       * @param list the list in which replacement is to occur.
       * @param oldVal the old value to be replaced.
       * @param newVal the new value with which <tt>oldVal</tt> is to be
       *        replaced.
       * @return <tt>true</tt> if <tt>list</tt> contained one or more elements
       *         <tt>e</tt> such that
       *         <tt>(oldVal==null ?  e==null : oldVal.equals(e))</tt>.
       * @throws UnsupportedOperationException if the specified list or
       *         its list-iterator does not support the <tt>set</tt> method.
       * @since  1.4
       */
      public static boolean replaceAll(List list, Object oldVal, Object newVal) {
          boolean result = false;
          int size = list.size();
>>        if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {
              if (oldVal==null) {
                  for (int i=0; i<size; i++) {
                      if (list.get(i)==null) {
                          list.set(i, newVal);
                          result = true;
                      }
                  }
              } else {
                  for (int i=0; i<size; i++) {
                      if (oldVal.equals(list.get(i))) {
                          list.set(i, newVal);
                          result = true;
                      }
                  }
              }
          } else {
              ListIterator itr=list.listIterator();
              if (oldVal==null) {
                  for (int i=0; i<size; i++) {
                      if (itr.next()==null) {
                          itr.set(newVal);
                          result = true;
                      }
                  }
              } else {
                  for (int i=0; i<size; i++) {
                      if (oldVal.equals(itr.next())) {
                          itr.set(newVal);
                          result = true;
                      }
                  }
              }
          }
          return result;
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: indirect-field collection-too-small

=========================================================

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=reverse,line=356,id=18,direction=true
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  method : java2.util2.Collections.reverse(java2.util2.List) : var1 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java2.util2.Collections.reverse((java2.util2.List)var1);

Variables: []
      /**
       * Reverses the order of the elements in the specified list.<p>
       *
       * This method runs in linear time.
       *
       * @param  list the list whose elements are to be reversed.
       * @throws UnsupportedOperationException if the specified list or
       *         its list-iterator does not support the <tt>set</tt> method.
       */
      public static void reverse(List list) {
          int size = list.size();
>>        if (size < REVERSE_THRESHOLD || list instanceof RandomAccess) {
              for (int i=0, mid=size>>1, j=size-1; i<mid; i++, j--)
                  swap(list, i, j);
          } else {
              ListIterator fwd = list.listIterator();
              ListIterator rev = list.listIterator(size);
              for (int i=0, mid=list.size()>>1; i<mid; i++) {
                  Object tmp = fwd.next();
                  fwd.set(rev.previous());
                  rev.set(tmp);
              }
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small instance-of

=================================================

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=shuffle,line=428,id=21,direction=true
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  method : java2.util2.Collections.shuffle(java2.util2.List) : var1 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java2.util2.Collections.shuffle((java2.util2.List)var1);

Variables: []
      /**
       * Randomly permute the specified list using the specified source of
       * randomness.  All permutations occur with equal likelihood
       * assuming that the source of randomness is fair.<p>
       *
       * This implementation traverses the list backwards, from the last element
       * up to the second, repeatedly swapping a randomly selected element into
       * the "current position".  Elements are randomly selected from the
       * portion of the list that runs from the first element to the current
       * position, inclusive.<p>
       *
       * This method runs in linear time.  If the specified list does not
       * implement the {@link RandomAccess} interface and is large, this
       * implementation dumps the specified list into an array before shuffling
       * it, and dumps the shuffled array back into the list.  This avoids the
       * quadratic behavior that would result from shuffling a "sequential
       * access" list in place.
       *
       * @param  list the list to be shuffled.
       * @param  rnd the source of randomness to use to shuffle the list.
       * @throws UnsupportedOperationException if the specified list or its
       *         list-iterator does not support the <tt>set</tt> operation.
       */
      public static void shuffle(List list, Random rnd) {
          int size = list.size();
>>        if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {
              for (int i=size; i>1; i--)
                  swap(list, i-1, rnd.nextInt(i));
          } else {
              Object arr[] = list.toArray();
  
              // Shuffle array
              for (int i=size; i>1; i--)
                  swap(arr, i-1, rnd.nextInt(i));
  
              // Dump array back into list
              ListIterator it = list.listIterator();
              for (int i=0; i<arr.length; i++) {
                  it.next();
                  it.set(arr[i]);
              }
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small instance-of

================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractMap,methodname=equals,line=513,id=27,direction=true
SEQUENCE
var0 =  cons : java2.util2.HashMap.<init>() : 
var1 =  prim : double:-1.0 : 
var2 =  prim : java.lang.String:"hi!" : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : java.lang.Object:null : 
var5 =  cons : java2.util2.HashMap.<init>() : 
var6 =  method : java2.util2.HashMap.values() : var5 
var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var6 
var8 =  method : java2.util2.AbstractMap.toString() : var0 
var9 =  prim : java.lang.String:"" : 
var10 =  method : java2.util2.HashMap.get(java.lang.Object) : var0 var9 
var11 =  cons : java2.util2.HashMap.<init>() : 
var12 =  prim : double:-1.0 : 
var13 =  prim : java.lang.String:"hi!" : 
var14 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var12 var13 
var15 =  prim : java.lang.Object:null : 
var16 =  cons : java2.util2.HashMap.<init>() : 
var17 =  method : java2.util2.HashMap.values() : var16 
var18 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var15 var17 
var19 =  method : java2.util2.AbstractMap.toString() : var11 
var20 =  prim : java.lang.Object:null : 
var21 =  method : java2.util2.HashMap.get(java.lang.Object) : var11 var20 
var22 =  prim : int:0 : 
var23 =  method : java2.util2.HashMap.remove(java.lang.Object) : var11 var22 
var24 =  method : java2.util2.AbstractMap.toString() : var11 
var25 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var11 

END RECORD

As source code:
java2.util2.HashMap var0 = new java2.util2.HashMap();
java.lang.Double var1 = new java.lang.Double((double)-1.0);
java.lang.String var2 = "hi!";
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = null;
java2.util2.HashMap var5 = new java2.util2.HashMap();
java2.util2.Collection var6 = var5.values();
java.lang.Object var7 = var0.put((java.lang.Object)var4, (java.lang.Object)var6);
java.lang.String var8 = var0.toString();
java.lang.String var9 = "";
java.lang.Object var10 = var0.get((java.lang.Object)var9);
java2.util2.HashMap var11 = new java2.util2.HashMap();
java.lang.Double var12 = new java.lang.Double((double)-1.0);
java.lang.String var13 = "hi!";
java.lang.Object var14 = var11.put((java.lang.Object)var12, (java.lang.Object)var13);
java.lang.Object var15 = null;
java2.util2.HashMap var16 = new java2.util2.HashMap();
java2.util2.Collection var17 = var16.values();
java.lang.Object var18 = var11.put((java.lang.Object)var15, (java.lang.Object)var17);
java.lang.String var19 = var11.toString();
java.lang.Object var20 = null;
java.lang.Object var21 = var11.get((java.lang.Object)var20);
java.lang.Integer var22 = new java.lang.Integer((int)0);
java.lang.Object var23 = var11.remove((java.lang.Object)var22);
java.lang.String var24 = var11.toString();
boolean var25 = var0.equals((java.lang.Object)var11);

Variables: []
      /**
       * Compares the specified object with this map for equality.  Returns
       * <tt>true</tt> if the given object is also a map and the two maps
       * represent the same mappings.  More formally, two maps <tt>t1</tt> and
       * <tt>t2</tt> represent the same mappings if
       * <tt>t1.keySet().equals(t2.keySet())</tt> and for every key <tt>k</tt>
       * in <tt>t1.keySet()</tt>, <tt> (t1.get(k)==null ? t2.get(k)==null :
       * t1.get(k).equals(t2.get(k))) </tt>.  This ensures that the
       * <tt>equals</tt> method works properly across different implementations
       * of the map interface.<p>
       *
       * This implementation first checks if the specified object is this map;
       * if so it returns <tt>true</tt>.  Then, it checks if the specified
       * object is a map whose size is identical to the size of this set; if
       * not, it it returns <tt>false</tt>.  If so, it iterates over this map's
       * <tt>entrySet</tt> collection, and checks that the specified map
       * contains each mapping that this map contains.  If the specified map
       * fails to contain such a mapping, <tt>false</tt> is returned.  If the
       * iteration completes, <tt>true</tt> is returned.
       *
       * @param o object to be compared for equality with this map.
       * @return <tt>true</tt> if the specified object is equal to this map.
       */
      public boolean equals(Object o) {
  	if (o == this)
  	    return true;
  
  	if (!(o instanceof Map))
  	    return false;
  	Map t = (Map) o;
  	if (t.size() != size())
  	    return false;
  
          try {
              Iterator i = entrySet().iterator();
>>            while (i.hasNext()) {
                  Entry e = (Entry) i.next();
                  Object key = e.getKey();
                  Object value = e.getValue();
                  if (value == null) {
                      if (!(t.get(key)==null && t.containsKey(key)))
                          return false;
                  } else {
                      if (!value.equals(t.get(key)))
                          return false;
                  }
              }
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
  
  	return true;
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: equals break-return-cf
 
===================================================

START RECORD
BRANCH 
classname=java2.util2.HashMap,methodname=addEntry,line=740,id=38,direction=false
SEQUENCE
var0 =  cons : java2.util2.HashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 

END RECORD

As source code:
java2.util2.HashMap var0 = new java2.util2.HashMap();
java.lang.Object var1 = null;
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);

Variables: []
      /**
       * Add a new entry with the specified key, value and hash code to
       * the specified bucket.  It is the responsibility of this 
       * method to resize the table if appropriate.
       *
       * Subclass overrides this to alter the behavior of put method.
       */
      void addEntry(int hash, Object key, Object value, int bucketIndex) {
          table[bucketIndex] = new Entry(hash, key, value, table[bucketIndex]);
>>        if (size++ >= threshold) 
              resize(2 * table.length);
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small no-df

==================================================
============================================================
START RECORD
BRANCH 
classname=java2.util2.HashMap,methodname=putAll,line=500,id=18,direction=false
SEQUENCE
var0 =  cons : java2.util2.HashMap.<init>() : 
var1 =  cons : java2.util2.HashMap.<init>() : 
var2 =  prim : double:-1.0 : 
var3 =  prim : java.lang.String:"hi!" : 
var4 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var1 var2 var3 
var5 =  method : java2.util2.HashMap.putAll(java2.util2.Map) : var0 var1 

END RECORD

As source code:
java2.util2.HashMap var0 = new java2.util2.HashMap();
java2.util2.HashMap var1 = new java2.util2.HashMap();
java.lang.Double var2 = new java.lang.Double((double)-1.0);
java.lang.String var3 = "hi!";
java.lang.Object var4 = var1.put((java.lang.Object)var2, (java.lang.Object)var3);
var0.putAll((java2.util2.Map)var1);

Variables: []
      /**
       * Copies all of the mappings from the specified map to this map
       * These mappings will replace any mappings that
       * this map had for any of the keys currently in the specified map.
       *
       * @param m mappings to be stored in this map.
       * @throws NullPointerException if the specified map is null.
       */
      public void putAll(Map m) {
          int numKeysToBeAdded = m.size();
          if (numKeysToBeAdded == 0)
              return;
  
          /*
           * Expand the map if the map if the number of mappings to be added
           * is greater than or equal to threshold.  This is conservative; the
           * obvious condition is (m.size() + size) >= threshold, but this
           * condition could result in a map with twice the appropriate capacity,
           * if the keys to be added overlap with the keys already in this map.
           * By using the conservative calculation, we subject ourself
           * to at most one extra resize.
           */
>>        if (numKeysToBeAdded > threshold) {
              int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);
              if (targetCapacity > MAXIMUM_CAPACITY)
                  targetCapacity = MAXIMUM_CAPACITY;
              int newCapacity = table.length;
              while (newCapacity < targetCapacity)
                  newCapacity <<= 1;
              if (newCapacity > table.length)
                  resize(newCapacity);
          }
  
          for (Iterator i = m.entrySet().iterator(); i.hasNext(); ) {
              Map.Entry e = (Map.Entry) i.next();
              put(e.getKey(), e.getValue());
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small indirect-field

============================================================
START RECORD
BRANCH 
classname=java2.util2.HashMap,methodname=putForCreate,line=413,id=12,direction=false
SEQUENCE
var0 =  cons : java2.util2.HashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : long:100 : 
var5 =  prim : java.lang.Object:null : 
var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var7 =  prim : char:20 : 
var8 =  prim : java.lang.Object:null : 
var9 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var7 var8 
var10 =  cons : java2.util2.HashMap.<init>(java2.util2.Map) : var0 

END RECORD

As source code:
java2.util2.HashMap var0 = new java2.util2.HashMap();
java.lang.Object var1 = null;
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Long var4 = new java.lang.Long((long)100);
java.lang.Object var5 = null;
java.lang.Object var6 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
java.lang.Character var7 = new java.lang.Character((char)' ');
java.lang.Object var8 = null;
java.lang.Object var9 = var0.put((java.lang.Object)var7, (java.lang.Object)var8);
java2.util2.HashMap var10 = new java2.util2.HashMap((java2.util2.Map)var0);

Variables: []
      /**
       * This method is used instead of put by constructors and
       * pseudoconstructors (clone, readObject).  It does not resize the table,
       * check for comodification, etc.  It calls createEntry rather than
       * addEntry.
       */
      private void putForCreate(Object key, Object value) {
          Object k = maskNull(key);
          int hash = hash(k);
          int i = indexFor(hash, table.length);
  
          /**
           * Look for preexisting entry for key.  This will never happen for
           * clone or deserialize.  It will only happen for construction if the
           * input Map is a sorted map whose ordering is inconsistent w/ equals.
           */
          for (Entry e = table[i]; e != null; e = e.next) {
>>            if (e.hash == hash && eq(k, e.key)) {
                  e.value = value;
                  return;
              }
          }
  
          createEntry(hash, k, value, i);
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem control-flow-boolean

============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=false
SEQUENCE
var0 =  cons : java2.util2.HashSet.<init>() : 
var1 =  prim : char:20 : 
var2 =  method : java2.util2.AbstractSet.equals(java.lang.Object) : var0 var1 

END RECORD

As source code:
java2.util2.HashSet var0 = new java2.util2.HashSet();
java.lang.Character var1 = new java.lang.Character((char)' ');
boolean var2 = var0.equals((java.lang.Object)var1);

Variables: []
      /**
       * Compares the specified object with this set for equality.  Returns
       * <tt>true</tt> if the given object is also a set, the two sets have
       * the same size, and every member of the given set is contained in
       * this set.  This ensures that the <tt>equals</tt> method works
       * properly across different implementations of the <tt>Set</tt>
       * interface.<p>
       *
       * This implementation first checks if the specified object is this
       * set; if so it returns <tt>true</tt>.  Then, it checks if the
       * specified object is a set whose size is identical to the size of
       * this set; if not, it it returns false.  If so, it returns
       * <tt>containsAll((Collection) o)</tt>.
       *
       * @param o Object to be compared for equality with this set.
       * @return <tt>true</tt> if the specified object is equal to this set.
       */
      public boolean equals(Object o) {
>>	if (o == this)
  	    return true;
  
  	if (!(o instanceof Set))
  	    return false;
  	Collection c = (Collection) o;
  	if (c.size() != size())
  	    return false;
          try {
              return containsAll(c);
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: equals bug

==================================================
START RECORD
BRANCH 
classname=java2.util2.HashMap,methodname=addEntry,line=740,id=38,direction=false
SEQUENCE
var0 =  cons : java2.util2.HashSet.<init>() : 
var1 =  prim : long:1 : 
var2 =  method : java2.util2.HashSet.add(java.lang.Object) : var0 var1 

END RECORD

As source code:
java2.util2.HashSet var0 = new java2.util2.HashSet();
java.lang.Long var1 = new java.lang.Long((long)1);
boolean var2 = var0.add((java.lang.Object)var1);

Variables: []
      /**
       * Add a new entry with the specified key, value and hash code to
       * the specified bucket.  It is the responsibility of this 
       * method to resize the table if appropriate.
       *
       * Subclass overrides this to alter the behavior of put method.
       */
      void addEntry(int hash, Object key, Object value, int bucketIndex) {
          table[bucketIndex] = new Entry(hash, key, value, table[bucketIndex]);
>>        if (size++ >= threshold) 
              resize(2 * table.length);
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: collection-too-small no-df

============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractSet,methodname=hashCode,line=102,id=4,direction=true
SEQUENCE
var0 =  cons : java2.util2.Hashtable.<init>() : 
var1 =  prim : long:10 : 
var2 =  prim : short:0 : 
var3 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  cons : java2.util2.Hashtable.<init>() : 
var5 =  prim : double:1.0 : 
var6 =  prim : float:100.0 : 
var7 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var4 var5 var6 
var8 =  method : java2.util2.Hashtable.putAll(java2.util2.Map) : var0 var4 
var9 =  prim : byte:1 : 
var10 =  cons : java.lang.Object.<init>() : 
var11 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var0 var9 var10 
var12 =  method : java2.util2.Hashtable.keys() : var0 
var13 =  method : java2.util2.Hashtable.elements() : var0 
var14 =  method : java2.util2.Hashtable.keySet() : var0 
var15 =  method : java2.util2.Hashtable.keySet() : var0 
var16 =  method : java2.util2.Hashtable.clone() : var0 
var17 =  method : java2.util2.Hashtable.values() : var0 
var18 =  method : java2.util2.Hashtable.entrySet() : var0 
var19 =  cons : java2.util2.Hashtable.<init>() : 
var20 =  prim : long:10 : 
var21 =  prim : short:0 : 
var22 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var19 var20 var21 
var23 =  cons : java2.util2.Hashtable.<init>() : 
var24 =  prim : double:1.0 : 
var25 =  prim : float:100.0 : 
var26 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var23 var24 var25 
var27 =  method : java2.util2.Hashtable.putAll(java2.util2.Map) : var19 var23 
var28 =  prim : byte:1 : 
var29 =  cons : java.lang.Object.<init>() : 
var30 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var19 var28 var29 
var31 =  method : java2.util2.Hashtable.isEmpty() : var19 
var32 =  cons : java2.util2.Hashtable.<init>() : 
var33 =  prim : long:10 : 
var34 =  prim : short:0 : 
var35 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var32 var33 var34 
var36 =  cons : java2.util2.Hashtable.<init>() : 
var37 =  prim : double:1.0 : 
var38 =  prim : float:100.0 : 
var39 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var36 var37 var38 
var40 =  method : java2.util2.Hashtable.putAll(java2.util2.Map) : var32 var36 
var41 =  prim : byte:1 : 
var42 =  cons : java.lang.Object.<init>() : 
var43 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var32 var41 var42 
var44 =  method : java2.util2.Hashtable.keys() : var32 
var45 =  method : java2.util2.Hashtable.elements() : var32 
var46 =  method : java2.util2.Hashtable.clone() : var32 
var47 =  method : java2.util2.Hashtable.remove(java.lang.Object) : var19 var32 
var48 =  method : java2.util2.Hashtable.keySet() : var19 
var49 =  method : java2.util2.Hashtable.get(java.lang.Object) : var0 var48 

END RECORD

As source code:
java2.util2.Hashtable var0 = new java2.util2.Hashtable();
java.lang.Long var1 = new java.lang.Long((long)10);
java.lang.Short var2 = new java.lang.Short((short)0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java2.util2.Hashtable var4 = new java2.util2.Hashtable();
java.lang.Double var5 = new java.lang.Double((double)1.0);
java.lang.Float var6 = new java.lang.Float((float)100.0);
java.lang.Object var7 = var4.put((java.lang.Object)var5, (java.lang.Object)var6);
var0.putAll((java2.util2.Map)var4);
java.lang.Byte var9 = new java.lang.Byte((byte)1);
java.lang.Object var10 = new java.lang.Object();
java.lang.Object var11 = var0.put((java.lang.Object)var9, (java.lang.Object)var10);
java2.util2.Enumeration var12 = var0.keys();
java2.util2.Enumeration var13 = var0.elements();
java2.util2.Set var14 = var0.keySet();
java2.util2.Set var15 = var0.keySet();
java.lang.Object var16 = var0.clone();
java2.util2.Collection var17 = var0.values();
java2.util2.Set var18 = var0.entrySet();
java2.util2.Hashtable var19 = new java2.util2.Hashtable();
java.lang.Long var20 = new java.lang.Long((long)10);
java.lang.Short var21 = new java.lang.Short((short)0);
java.lang.Object var22 = var19.put((java.lang.Object)var20, (java.lang.Object)var21);
java2.util2.Hashtable var23 = new java2.util2.Hashtable();
java.lang.Double var24 = new java.lang.Double((double)1.0);
java.lang.Float var25 = new java.lang.Float((float)100.0);
java.lang.Object var26 = var23.put((java.lang.Object)var24, (java.lang.Object)var25);
var19.putAll((java2.util2.Map)var23);
java.lang.Byte var28 = new java.lang.Byte((byte)1);
java.lang.Object var29 = new java.lang.Object();
java.lang.Object var30 = var19.put((java.lang.Object)var28, (java.lang.Object)var29);
boolean var31 = var19.isEmpty();
java2.util2.Hashtable var32 = new java2.util2.Hashtable();
java.lang.Long var33 = new java.lang.Long((long)10);
java.lang.Short var34 = new java.lang.Short((short)0);
java.lang.Object var35 = var32.put((java.lang.Object)var33, (java.lang.Object)var34);
java2.util2.Hashtable var36 = new java2.util2.Hashtable();
java.lang.Double var37 = new java.lang.Double((double)1.0);
java.lang.Float var38 = new java.lang.Float((float)100.0);
java.lang.Object var39 = var36.put((java.lang.Object)var37, (java.lang.Object)var38);
var32.putAll((java2.util2.Map)var36);
java.lang.Byte var41 = new java.lang.Byte((byte)1);
java.lang.Object var42 = new java.lang.Object();
java.lang.Object var43 = var32.put((java.lang.Object)var41, (java.lang.Object)var42);
java2.util2.Enumeration var44 = var32.keys();
java2.util2.Enumeration var45 = var32.elements();
java.lang.Object var46 = var32.clone();
java.lang.Object var47 = var19.remove((java.lang.Object)var32);
java2.util2.Set var48 = var19.keySet();
java.lang.Object var49 = var0.get((java.lang.Object)var48);

Variables: []
      /**
       * Returns the hash code value for this set.  The hash code of a set is
       * defined to be the sum of the hash codes of the elements in the set.
       * This ensures that <tt>s1.equals(s2)</tt> implies that
       * <tt>s1.hashCode()==s2.hashCode()</tt> for any two sets <tt>s1</tt>
       * and <tt>s2</tt>, as required by the general contract of
       * Object.hashCode.<p>
       *
       * This implementation enumerates over the set, calling the
       * <tt>hashCode</tt> method on each element in the collection, and
       * adding up the results.
       *
       * @return the hash code value for this set.
       */
      public int hashCode() {
  	int h = 0;
  	Iterator i = iterator();
  	while (i.hasNext()) {
  	    Object obj = i.next();
>>            if (obj != null)
                  h += obj.hashCode();
          }
  	return h;
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: bug

============================================================
START RECORD
BRANCH 
classname=java2.util2.Hashtable,methodname=containsKey,line=314,id=8,direction=false
SEQUENCE
var0 =  cons : java2.util2.Hashtable.<init>() : 
var1 =  prim : long:10 : 
var2 =  prim : short:0 : 
var3 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  cons : java2.util2.Hashtable.<init>() : 
var5 =  prim : double:1.0 : 
var6 =  prim : float:100.0 : 
var7 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var4 var5 var6 
var8 =  method : java2.util2.Hashtable.putAll(java2.util2.Map) : var0 var4 
var9 =  prim : byte:1 : 
var10 =  cons : java.lang.Object.<init>() : 
var11 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var0 var9 var10 
var12 =  method : java2.util2.Hashtable.elements() : var0 
var13 =  cons : java2.util2.Hashtable.<init>() : 
var14 =  method : java2.util2.Hashtable.containsKey(java.lang.Object) : var0 var13 

END RECORD

As source code:
java2.util2.Hashtable var0 = new java2.util2.Hashtable();
java.lang.Long var1 = new java.lang.Long((long)10);
java.lang.Short var2 = new java.lang.Short((short)0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java2.util2.Hashtable var4 = new java2.util2.Hashtable();
java.lang.Double var5 = new java.lang.Double((double)1.0);
java.lang.Float var6 = new java.lang.Float((float)100.0);
java.lang.Object var7 = var4.put((java.lang.Object)var5, (java.lang.Object)var6);
var0.putAll((java2.util2.Map)var4);
java.lang.Byte var9 = new java.lang.Byte((byte)1);
java.lang.Object var10 = new java.lang.Object();
java.lang.Object var11 = var0.put((java.lang.Object)var9, (java.lang.Object)var10);
java2.util2.Enumeration var12 = var0.elements();
java2.util2.Hashtable var13 = new java2.util2.Hashtable();
boolean var14 = var0.containsKey((java.lang.Object)var13);

Variables: []
      /**
       * Tests if the specified object is a key in this hashtable.
       * 
       * @param   key   possible key.
       * @return  <code>true</code> if and only if the specified object 
       *          is a key in this hashtable, as determined by the 
       *          <tt>equals</tt> method; <code>false</code> otherwise.
       * @throws  NullPointerException  if the key is <code>null</code>.
       * @see     #contains(Object)
       */
      public synchronized boolean containsKey(Object key) {
  	Entry tab[] = table;
  	int hash = key.hashCode();
  	int index = (hash & 0x7FFFFFFF) % tab.length;
  	for (Entry e = tab[index] ; e != null ; e = e.next) {
>>	    if ((e.hash == hash) && e.key.equals(key)) {
  		return true;
  	    }
  	}
  	return false;
      }


NO DATAFLOW INFORMATION. WILL SKIP TO NEXT SEQUENCE.
Problem: hash
