
============================================================

    // Can be reached with the following modified sequence:
    // This may work by iterating over existing bitset sequences AND
    // mutating them (to get 1000), then adding them as params.

// START RECORD
// BRANCH 
// classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
// SEQUENCE
// var0 =  cons : java2.util2.BitSet.<init>() : 
// var1 =  prim : int:10 : 
// var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
// var3 =  prim : int:0 : 
// var4 =  prim : int:10 : 
// var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
// var6 =  prim : int:0 : 
// var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
// var8 =  prim : int:0 : 
// var9 =  prim : int:10 : 
// var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
// var11 =  prim : int:0 : 
// var12 =  prim : int:100 : 
// var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
// var14 =  prim : int:1 : 
// var15 =  method : java2.util2.BitSet.set(int) : var10 var14 
// var16 =  cons : java2.util2.BitSet.<init>() : 
// var17 =  prim : int:10 : 
// var18 =  method : java2.util2.BitSet.flip(int) : var16 var17 
// var19 =  method : java2.util2.BitSet.xor(java2.util2.BitSet) : var10 var16 
// var20 =  cons : java2.util2.BitSet.<init>() : 
// x = cons : java2.util2.BitSet.<init>() : 
// i = prim : int:1000 : 
// y =  method : java2.util2.BitSet.set(int) : x i
// var21 =  method : java2.util2.BitSet.equals(java.lang.Object) : x var20 

// END RECORD


START RECORD
BRANCH 
classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=true
SEQUENCE
var0 =  cons : java2.util2.BitSet.<init>() : 
var1 =  prim : int:10 : 
var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
var3 =  prim : int:0 : 
var4 =  prim : int:10 : 
var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
var6 =  prim : int:0 : 
var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
var8 =  prim : int:0 : 
var9 =  prim : int:10 : 
var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
var11 =  prim : int:0 : 
var12 =  prim : int:100 : 
var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
var14 =  prim : int:1 : 
var15 =  method : java2.util2.BitSet.set(int) : var10 var14 
var16 =  cons : java2.util2.BitSet.<init>() : 
var17 =  prim : int:10 : 
var18 =  method : java2.util2.BitSet.flip(int) : var16 var17 
var19 =  method : java2.util2.BitSet.xor(java2.util2.BitSet) : var10 var16 
var20 =  cons : java2.util2.BitSet.<init>() : 
var21 =  method : java2.util2.BitSet.equals(java.lang.Object) : var10 var20 

END RECORD

As source code:
java2.util2.BitSet var0 = new java2.util2.BitSet();
java.lang.Integer var1 = new java.lang.Integer((int)10);
var0.flip((int)var1);
java.lang.Integer var3 = new java.lang.Integer((int)0);
java.lang.Integer var4 = new java.lang.Integer((int)10);
var0.flip((int)var3, (int)var4);
java.lang.Integer var6 = new java.lang.Integer((int)0);
var0.clear((int)var6);
java.lang.Integer var8 = new java.lang.Integer((int)0);
java.lang.Integer var9 = new java.lang.Integer((int)10);
java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
java.lang.Integer var11 = new java.lang.Integer((int)0);
java.lang.Integer var12 = new java.lang.Integer((int)100);
var10.flip((int)var11, (int)var12);
java.lang.Integer var14 = new java.lang.Integer((int)1);
var10.set((int)var14);
java2.util2.BitSet var16 = new java2.util2.BitSet();
java.lang.Integer var17 = new java.lang.Integer((int)10);
var16.flip((int)var17);
var10.xor((java2.util2.BitSet)var16);
java2.util2.BitSet var20 = new java2.util2.BitSet();
boolean var21 = var10.equals((java.lang.Object)var20);

Variables: [var14:[0], var17:[0], var11:[0]]
      /**
       * Compares this object against the specified object.
       * The result is <code>true</code> if and only if the argument is 
       * not <code>null</code> and is a <code>Bitset</code> object that has 
       * exactly the same set of bits set to <code>true</code> as this bit 
       * set. That is, for every nonnegative <code>int</code> index <code>k</code>, 
       * <pre>((BitSet)obj).get(k) == this.get(k)</pre>
       * must be true. The current sizes of the two bit sets are not compared. 
       * <p>Overrides the <code>equals</code> method of <code>Object</code>.
       *
       * @param   obj   the object to compare with.
       * @return  <code>true</code> if the objects are the same;
       *          <code>false</code> otherwise.
       * @see     java2.util2.BitSet#size()
       */
      public boolean equals(Object obj) {
  	if (!(obj instanceof BitSet))
  	    return false;
  	if (this == obj)
  	    return true;
  
  	BitSet set = (BitSet) obj;
  	int minUnitsInUse = Math.min(unitsInUse, set.unitsInUse);
  
  	// Check units in use by both BitSets
  	for (int i = 0; i < minUnitsInUse; i++)
  	    if (bits[i] != set.bits[i])
  		return false;
  
  	// Check any units in use by only one BitSet (must be 0 in other)
  	if (unitsInUse > minUnitsInUse) {
  	    for (int i = minUnitsInUse; i<unitsInUse; i++)
>>		if (bits[i] != 0)
  		    return false;
  	} else {
  	    for (int i = minUnitsInUse; i<set.unitsInUse; i++)
  		if (set.bits[i] != 0)
  		    return false;
  	}
  
  	return true;
      }


WILL TRY TO REPLACE var14 WITH var11
WILL TRY TO REPLACE var17 WITH var11
WILL TRY TO REPLACE var17 WITH var14
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
WILL TRY REPLACING var14 WITH VALUE 0
WILL TRY NEGATING var14
WILL TRY SETTING TO ZERO var14
WILL TRY ADDING 1 var14
WILL TRY SUBTRACTING 1 var14
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
WILL TRY REPLACING var17 WITH VALUE 0
WILL TRY NEGATING var17
WILL TRY SETTING TO ZERO var17
WILL TRY ADDING 1 var17
WILL TRY SUBTRACTING 1 var17
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
WILL TRY REPLACING var11 WITH VALUE 0
WILL TRY NEGATING var11
WILL TRY SETTING TO ZERO var11
WILL TRY ADDING 1 var11
WILL TRY SUBTRACTING 1 var11
FAILURE

===============================================================

    // TODO

START RECORD
BRANCH 
classname=java2.util2.BitSet,methodname=nextClearBit,line=653,id=66,direction=false
SEQUENCE
var0 =  cons : java2.util2.BitSet.<init>() : 
var1 =  prim : int:0 : 
var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
var3 =  prim : int:0 : 
var4 =  method : java2.util2.BitSet.nextClearBit(int) : var0 var3 

END RECORD

As source code:
java2.util2.BitSet var0 = new java2.util2.BitSet();
java.lang.Integer var1 = new java.lang.Integer((int)0);
var0.flip((int)var1);
java.lang.Integer var3 = new java.lang.Integer((int)0);
int var4 = var0.nextClearBit((int)var3);

Variables: [var3:[0], var1:[0]]
      /**
       * Returns the index of the first bit that is set to <code>false</code>
       * that occurs on or after the specified starting index.
       * 
       * @param   fromIndex the index to start checking from (inclusive).
       * @return  the index of the next clear bit.
       * @throws  IndexOutOfBoundsException if the specified index is negative.
       * @since   1.4
       */
      public int nextClearBit(int fromIndex) {
  	if (fromIndex < 0)
  	    throw new IndexOutOfBoundsException("fromIndex < 0: " + fromIndex);
  
          int u = unitIndex(fromIndex);
          if (u >= unitsInUse)
              return fromIndex;
          int testIndex = (fromIndex & BIT_INDEX_MASK);
          long unit = bits[u] >> testIndex;
  
          if (unit == (WORD_MASK >> testIndex))
              testIndex = 0;
  
          while((unit==WORD_MASK) && (u < unitsInUse-1))
              unit = bits[++u];
  
>>        if (unit == WORD_MASK)
              return length();
          
          if (unit == 0)
              return u * BITS_PER_UNIT + testIndex;
  
          testIndex += trailingZeroCnt(~unit);
          return ((u * BITS_PER_UNIT) + testIndex);
      }


WILL TRY TO REPLACE var3 WITH var1
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=nextClearBit,line=653,id=66,direction=true
WILL TRY REPLACING var3 WITH VALUE 0
WILL TRY NEGATING var3
WILL TRY SETTING TO ZERO var3
WILL TRY ADDING 1 var3
WILL TRY SUBTRACTING 1 var3
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=nextClearBit,line=653,id=66,direction=true
WILL TRY REPLACING var1 WITH VALUE 0
WILL TRY NEGATING var1
WILL TRY SETTING TO ZERO var1
WILL TRY ADDING 1 var1
WILL TRY SUBTRACTING 1 var1
FAILURE
============================================================


    // TODO

START RECORD
BRANCH 
classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=587,id=58,direction=false
SEQUENCE
var0 =  cons : java2.util2.BitSet.<init>() : 
var1 =  prim : int:10 : 
var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
var3 =  prim : int:0 : 
var4 =  prim : int:10 : 
var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
var6 =  prim : int:0 : 
var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
var8 =  prim : int:0 : 
var9 =  prim : int:10 : 
var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
var11 =  prim : int:0 : 
var12 =  prim : int:100 : 
var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
var14 =  prim : int:10 : 
var15 =  method : java2.util2.BitSet.nextClearBit(int) : var10 var14 

END RECORD

As source code:
java2.util2.BitSet var0 = new java2.util2.BitSet();
java.lang.Integer var1 = new java.lang.Integer((int)10);
var0.flip((int)var1);
java.lang.Integer var3 = new java.lang.Integer((int)0);
java.lang.Integer var4 = new java.lang.Integer((int)10);
var0.flip((int)var3, (int)var4);
java.lang.Integer var6 = new java.lang.Integer((int)0);
var0.clear((int)var6);
java.lang.Integer var8 = new java.lang.Integer((int)0);
java.lang.Integer var9 = new java.lang.Integer((int)10);
java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
java.lang.Integer var11 = new java.lang.Integer((int)0);
java.lang.Integer var12 = new java.lang.Integer((int)100);
var10.flip((int)var11, (int)var12);
java.lang.Integer var14 = new java.lang.Integer((int)10);
int var15 = var10.nextClearBit((int)var14);

Variables: [var12:[0], var14:[0]]
      private static int trailingZeroCnt(long val) {
          // Loop unrolled for performance
          int byteVal = (int)val & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal];
  
          byteVal = (int)(val >>> 8) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 8;
  
          byteVal = (int)(val >>> 16) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 16;
  
          byteVal = (int)(val >>> 24) & 0xff;
>>        if (byteVal != 0)
              return trailingZeroTable[byteVal] + 24;
  
          byteVal = (int)(val >>> 32) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 32;
  
          byteVal = (int)(val >>> 40) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 40;
  
          byteVal = (int)(val >>> 48) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 48;
  
          byteVal = (int)(val >>> 56) & 0xff;
          return trailingZeroTable[byteVal] + 56;
      }


WILL TRY TO REPLACE var14 WITH var12
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=587,id=58,direction=true
WILL TRY REPLACING var12 WITH VALUE 0
WILL TRY NEGATING var12
WILL TRY SETTING TO ZERO var12
WILL TRY ADDING 1 var12
WILL TRY SUBTRACTING 1 var12
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=587,id=58,direction=true
WILL TRY REPLACING var14 WITH VALUE 0
WILL TRY NEGATING var14
WILL TRY SETTING TO ZERO var14
WILL TRY ADDING 1 var14
WILL TRY SUBTRACTING 1 var14
FAILURE
============================================================

    // TODO

START RECORD
BRANCH 
classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=591,id=59,direction=true
SEQUENCE
var0 =  cons : java2.util2.BitSet.<init>() : 
var1 =  prim : int:10 : 
var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
var3 =  prim : int:0 : 
var4 =  prim : int:10 : 
var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
var6 =  prim : int:0 : 
var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
var8 =  prim : int:0 : 
var9 =  prim : int:10 : 
var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
var11 =  prim : int:0 : 
var12 =  prim : int:100 : 
var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
var14 =  prim : int:10 : 
var15 =  method : java2.util2.BitSet.nextClearBit(int) : var10 var14 

END RECORD

As source code:
java2.util2.BitSet var0 = new java2.util2.BitSet();
java.lang.Integer var1 = new java.lang.Integer((int)10);
var0.flip((int)var1);
java.lang.Integer var3 = new java.lang.Integer((int)0);
java.lang.Integer var4 = new java.lang.Integer((int)10);
var0.flip((int)var3, (int)var4);
java.lang.Integer var6 = new java.lang.Integer((int)0);
var0.clear((int)var6);
java.lang.Integer var8 = new java.lang.Integer((int)0);
java.lang.Integer var9 = new java.lang.Integer((int)10);
java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
java.lang.Integer var11 = new java.lang.Integer((int)0);
java.lang.Integer var12 = new java.lang.Integer((int)100);
var10.flip((int)var11, (int)var12);
java.lang.Integer var14 = new java.lang.Integer((int)10);
int var15 = var10.nextClearBit((int)var14);

Variables: [var12:[0], var14:[0]]
      private static int trailingZeroCnt(long val) {
          // Loop unrolled for performance
          int byteVal = (int)val & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal];
  
          byteVal = (int)(val >>> 8) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 8;
  
          byteVal = (int)(val >>> 16) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 16;
  
          byteVal = (int)(val >>> 24) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 24;
  
          byteVal = (int)(val >>> 32) & 0xff;
>>        if (byteVal != 0)
              return trailingZeroTable[byteVal] + 32;
  
          byteVal = (int)(val >>> 40) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 40;
  
          byteVal = (int)(val >>> 48) & 0xff;
          if (byteVal != 0)
              return trailingZeroTable[byteVal] + 48;
  
          byteVal = (int)(val >>> 56) & 0xff;
          return trailingZeroTable[byteVal] + 56;
      }


WILL TRY TO REPLACE var14 WITH var12
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=591,id=59,direction=false
WILL TRY REPLACING var12 WITH VALUE 0
WILL TRY NEGATING var12
WILL TRY SETTING TO ZERO var12
WILL TRY ADDING 1 var12
WILL TRY SUBTRACTING 1 var12
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=591,id=59,direction=false
WILL TRY REPLACING var14 WITH VALUE 0
WILL TRY NEGATING var14
WILL TRY SETTING TO ZERO var14
WILL TRY ADDING 1 var14
WILL TRY SUBTRACTING 1 var14
FAILURE
============================================================

    // This seq will never get us past the branch. Need to try another
    // one. Should be pretty easy to reach.

START RECORD
BRANCH 
classname=java2.util2.AbstractList,methodname=listIterator,line=388,id=11,direction=false
SEQUENCE
var0 =  prim : long:-1 : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  method : java2.util2.Collections.sort(java2.util2.List) : var1 

END RECORD

As source code:
java.lang.Long var0 = new java.lang.Long((long)-1);
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java2.util2.Collections.sort((java2.util2.List)var1);

Variables: [var0:[0]]
      /**
       * Returns a list iterator of the elements in this list (in proper
       * sequence), starting at the specified position in the list.  The
       * specified index indicates the first element that would be returned by
       * an initial call to the <tt>next</tt> method.  An initial call to
       * the <tt>previous</tt> method would return the element with the
       * specified index minus one.<p>
       *
       * This implementation returns a straightforward implementation of the
       * <tt>ListIterator</tt> interface that extends the implementation of the
       * <tt>Iterator</tt> interface returned by the <tt>iterator()</tt> method.
       * The <tt>ListIterator</tt> implementation relies on the backing list's
       * <tt>get(int)</tt>, <tt>set(int, Object)</tt>, <tt>add(int, Object)</tt>
       * and <tt>remove(int)</tt> methods.<p>
       *
       * Note that the list iterator returned by this implementation will throw
       * an <tt>UnsupportedOperationException</tt> in response to its
       * <tt>remove</tt>, <tt>set</tt> and <tt>add</tt> methods unless the
       * list's <tt>remove(int)</tt>, <tt>set(int, Object)</tt>, and
       * <tt>add(int, Object)</tt> methods are overridden.<p>
       *
       * This implementation can be made to throw runtime exceptions in the
       * face of concurrent modification, as described in the specification for
       * the (protected) <tt>modCount</tt> field.
       *
       * @param index index of the first element to be returned from the list
       *		    iterator (by a call to the <tt>next</tt> method).
       * 
       * @return a list iterator of the elements in this list (in proper
       * 	       sequence), starting at the specified position in the list.
       * 
       * @throws IndexOutOfBoundsException if the specified index is out of
       *		  range (<tt>index &lt; 0 || index &gt; size()</tt>).
       * 
       * @see #modCount
       */
      public ListIterator listIterator(final int index) {
>>	if (index<0 || index>size())
  	  throw new IndexOutOfBoundsException("Index: "+index);
  
  	return new ListItr(index);
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractList,methodname=listIterator,line=388,id=11,direction=true
FAILURE
============================================================

    // Covered by (1) replicating var14 (call the replica z), and (2)
    // replacing var3 occurrences with z.

    // DF says var3 is interesting. var14 is interesting because it is
    // in the method call that reaches the frontier branch.

// START RECORD
// BRANCH 
// classname=java2.util2.AbstractMap,methodname=equals,line=505,id=25,direction=false
// SEQUENCE

// x =  prim : java.lang.Object:null : 
// y =  prim : double:0.0 : 
// z =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : x y

// var0 =  prim : int:100 : 
// var1 =  prim : short:10 : 
// var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
// var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
// var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 z
// var5 =  prim : long:1 : 
// var6 =  prim : java.lang.Object:null : 
// var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
// var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
// var9 =  prim : char:34 : 
// var10 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var9 
// var11 =  method : java2.util2.Collections.lastIndexOfSubList(java2.util2.List,java2.util2.List) : var4 var10 
// var12 =  prim : java.lang.Object:null : 
// var13 =  prim : double:0.0 : 
// var14 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var12 var13 
// var15 =  prim : java.lang.Object:null : 
// var16 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var14 var15 

// END RECORD


START RECORD
BRANCH 
classname=java2.util2.AbstractMap,methodname=equals,line=505,id=25,direction=true
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : short:10 : 
var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
var5 =  prim : long:1 : 
var6 =  prim : java.lang.Object:null : 
var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
var9 =  prim : char:34 : 
var10 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var9 
var11 =  method : java2.util2.Collections.lastIndexOfSubList(java2.util2.List,java2.util2.List) : var4 var10 
var12 =  prim : java.lang.Object:null : 
var13 =  prim : double:0.0 : 
var14 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var12 var13 
var15 =  prim : java.lang.Object:null : 
var16 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var14 var15 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Short var1 = new java.lang.Short((short)10);
java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
java.lang.Long var5 = new java.lang.Long((long)1);
java.lang.Object var6 = null;
boolean var7 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var5, (java.lang.Object)var6);
java2.util2.Enumeration var8 = java2.util2.Collections.enumeration((java2.util2.Collection)var4);
java.lang.Character var9 = new java.lang.Character((char)'4');
java2.util2.List var10 = java2.util2.Collections.singletonList((java.lang.Object)var9);
int var11 = java2.util2.Collections.lastIndexOfSubList((java2.util2.List)var4, (java2.util2.List)var10);
java.lang.Object var12 = null;
java.lang.Double var13 = new java.lang.Double((double)0.0);
java2.util2.Map var14 = java2.util2.Collections.singletonMap((java.lang.Object)var12, (java.lang.Object)var13);
java.lang.Object var15 = null;
boolean var16 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var14, (java.lang.Object)var15);

Variables: [var3:[0]]
      /**
       * Compares the specified object with this map for equality.  Returns
       * <tt>true</tt> if the given object is also a map and the two maps
       * represent the same mappings.  More formally, two maps <tt>t1</tt> and
       * <tt>t2</tt> represent the same mappings if
       * <tt>t1.keySet().equals(t2.keySet())</tt> and for every key <tt>k</tt>
       * in <tt>t1.keySet()</tt>, <tt> (t1.get(k)==null ? t2.get(k)==null :
       * t1.get(k).equals(t2.get(k))) </tt>.  This ensures that the
       * <tt>equals</tt> method works properly across different implementations
       * of the map interface.<p>
       *
       * This implementation first checks if the specified object is this map;
       * if so it returns <tt>true</tt>.  Then, it checks if the specified
       * object is a map whose size is identical to the size of this set; if
       * not, it it returns <tt>false</tt>.  If so, it iterates over this map's
       * <tt>entrySet</tt> collection, and checks that the specified map
       * contains each mapping that this map contains.  If the specified map
       * fails to contain such a mapping, <tt>false</tt> is returned.  If the
       * iteration completes, <tt>true</tt> is returned.
       *
       * @param o object to be compared for equality with this map.
       * @return <tt>true</tt> if the specified object is equal to this map.
       */
      public boolean equals(Object o) {
  	if (o == this)
  	    return true;
  
>>	if (!(o instanceof Map))
  	    return false;
  	Map t = (Map) o;
  	if (t.size() != size())
  	    return false;
  
          try {
              Iterator i = entrySet().iterator();
              while (i.hasNext()) {
                  Entry e = (Entry) i.next();
                  Object key = e.getKey();
                  Object value = e.getValue();
                  if (value == null) {
                      if (!(t.get(key)==null && t.containsKey(key)))
                          return false;
                  } else {
                      if (!value.equals(t.get(key)))
                          return false;
                  }
              }
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
  
  	return true;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=505,id=25,direction=false
FAILURE
============================================================

    // Covered if (1) replicate var11 -> varb, (2) replace uses of var3 with varb.
    // var11 is is interesting because it's in method that executes frontier branch.

// START RECORD
// BRANCH 
// classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
// SEQUENCE

// var10 =  prim : short:10 : 
// var11 =  method : java2.util2.Collections.singleton(java.lang.Object) : var10 

// vara =  prim : short:10 : 
// varb =  method : java2.util2.Collections.singleton(java.lang.Object) : vara

// var0 =  prim : int:100 : 
// var1 =  prim : short:10 : 
// var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
// var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
// var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 varb
// var5 =  prim : long:1 : 
// var6 =  prim : java.lang.Object:null : 
// var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
// var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
// var9 =  prim : java.lang.Object:null : 


// var12 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
// var13 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
// var14 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
// var15 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var9 var11 
// var16 =  prim : java.lang.Object:null : 
// var17 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var11 var16 

// END RECORD

START RECORD
BRANCH 
classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=true
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : short:10 : 
var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
var5 =  prim : long:1 : 
var6 =  prim : java.lang.Object:null : 
var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
var9 =  prim : java.lang.Object:null : 
var10 =  prim : short:10 : 
var11 =  method : java2.util2.Collections.singleton(java.lang.Object) : var10 
var12 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
var13 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
var14 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
var15 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var9 var11 
var16 =  prim : java.lang.Object:null : 
var17 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var11 var16 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Short var1 = new java.lang.Short((short)10);
java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
java.lang.Long var5 = new java.lang.Long((long)1);
java.lang.Object var6 = null;
boolean var7 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var5, (java.lang.Object)var6);
java2.util2.Enumeration var8 = java2.util2.Collections.enumeration((java2.util2.Collection)var4);
java.lang.Object var9 = null;
java.lang.Short var10 = new java.lang.Short((short)10);
java2.util2.Set var11 = java2.util2.Collections.singleton((java.lang.Object)var10);
java2.util2.Collection var12 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var11);
java2.util2.Collection var13 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var11);
java2.util2.Collection var14 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var11);
java2.util2.Map var15 = java2.util2.Collections.singletonMap((java.lang.Object)var9, (java.lang.Object)var11);
java.lang.Object var16 = null;
boolean var17 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var11, (java.lang.Object)var16);

Variables: [var3:[0]]
      /**
       * Compares the specified object with this set for equality.  Returns
       * <tt>true</tt> if the given object is also a set, the two sets have
       * the same size, and every member of the given set is contained in
       * this set.  This ensures that the <tt>equals</tt> method works
       * properly across different implementations of the <tt>Set</tt>
       * interface.<p>
       *
       * This implementation first checks if the specified object is this
       * set; if so it returns <tt>true</tt>.  Then, it checks if the
       * specified object is a set whose size is identical to the size of
       * this set; if not, it it returns false.  If so, it returns
       * <tt>containsAll((Collection) o)</tt>.
       *
       * @param o Object to be compared for equality with this set.
       * @return <tt>true</tt> if the specified object is equal to this set.
       */
      public boolean equals(Object o) {
  	if (o == this)
  	    return true;
  
>>	if (!(o instanceof Set))
  	    return false;
  	Collection c = (Collection) o;
  	if (c.size() != size())
  	    return false;
          try {
              return containsAll(c);
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
FAILURE
============================================================

    // There's no way this sequence will work, because we need to
    // increase the lists's size. And even if we get a mutable list,
    // we need to increase it by >5000 elements... Not an easy one...

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=binarySearch,line=197,id=2,direction=true
SEQUENCE
var0 =  prim : char:34 : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.Collections.binarySearch(java2.util2.List,java.lang.Object) : var1 var2 

END RECORD

As source code:
java.lang.Character var0 = new java.lang.Character((char)'4');
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Object var2 = null;
int var3 = java2.util2.Collections.binarySearch((java2.util2.List)var1, (java.lang.Object)var2);

Variables: [var1:[0]]
      /**
       * Searches the specified list for the specified object using the binary
       * search algorithm.  The list must be sorted into ascending order
       * according to the <i>natural ordering</i> of its elements (as by the
       * <tt>sort(List)</tt> method, above) prior to making this call.  If it is
       * not sorted, the results are undefined.  If the list contains multiple
       * elements equal to the specified object, there is no guarantee which one
       * will be found.<p>
       *
       * This method runs in log(n) time for a "random access" list (which
       * provides near-constant-time positional access).  If the specified list
       * does not implement the {@link RandomAccess} and is large, this method
       * will do an iterator-based binary search that performs O(n) link
       * traversals and O(log n) element comparisons.
       *
       * @param  list the list to be searched.
       * @param  key the key to be searched for.
       * @return index of the search key, if it is contained in the list;
       *	       otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
       *	       <i>insertion point</i> is defined as the point at which the
       *	       key would be inserted into the list: the index of the first
       *	       element greater than the key, or <tt>list.size()</tt>, if all
       *	       elements in the list are less than the specified key.  Note
       *	       that this guarantees that the return value will be &gt;= 0 if
       *	       and only if the key is found.
       * @throws ClassCastException if the list contains elements that are not
       *	       <i>mutually comparable</i> (for example, strings and
       *	       integers), or the search key in not mutually comparable
       *	       with the elements of the list.
       * @see    Comparable
       * @see #sort(List)
       */
      public static int binarySearch(List list, Object key) {
>>        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
              return indexedBinarySearch(list, key);
          else
              return iteratorBinarySearch(list, key);
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=binarySearch,line=197,id=2,direction=false
FAILURE
============================================================

    // Same as above.

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=binarySearch,line=300,id=11,direction=true
SEQUENCE
var0 =  prim : double:10.0 : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.Collections.reverseOrder() : 
var4 =  method : java2.util2.Collections.binarySearch(java2.util2.List,java.lang.Object,java2.util2.Comparator) : var1 var2 var3 

END RECORD

As source code:
java.lang.Double var0 = new java.lang.Double((double)10.0);
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Object var2 = null;
java2.util2.Comparator var3 = java2.util2.Collections.reverseOrder();
int var4 = java2.util2.Collections.binarySearch((java2.util2.List)var1, (java.lang.Object)var2, (java2.util2.Comparator)var3);

Variables: [var1:[0]]
      /**
       * Searches the specified list for the specified object using the binary
       * search algorithm.  The list must be sorted into ascending order
       * according to the specified comparator (as by the <tt>Sort(List,
       * Comparator)</tt> method, above), prior to making this call.  If it is
       * not sorted, the results are undefined.  If the list contains multiple
       * elements equal to the specified object, there is no guarantee which one
       * will be found.<p>
       *
       * This method runs in log(n) time for a "random access" list (which
       * provides near-constant-time positional access).  If the specified list
       * does not implement the {@link RandomAccess} and is large, this
       * this method will do an iterator-based binary search that performs
       * O(n) link traversals and O(log n) element comparisons.
       *
       * @param  list the list to be searched.
       * @param  key the key to be searched for.
       * @param  c the comparator by which the list is ordered.  A
       *        <tt>null</tt> value indicates that the elements' <i>natural
       *        ordering</i> should be used.
       * @return index of the search key, if it is contained in the list;
       *	       otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
       *	       <i>insertion point</i> is defined as the point at which the
       *	       key would be inserted into the list: the index of the first
       *	       element greater than the key, or <tt>list.size()</tt>, if all
       *	       elements in the list are less than the specified key.  Note
       *	       that this guarantees that the return value will be &gt;= 0 if
       *	       and only if the key is found.
       * @throws ClassCastException if the list contains elements that are not
       *	       <i>mutually comparable</i> using the specified comparator,
       *	       or the search key in not mutually comparable with the
       *	       elements of the list using this comparator.
       * @see    Comparable
       * @see #sort(List, Comparator)
       */
      public static int binarySearch(List list, Object key, Comparator c) {
          if (c==null)
              return binarySearch(list, key);
  
>>        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
              return indexedBinarySearch(list, key, c);
          else
              return iteratorBinarySearch(list, key, c);
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=binarySearch,line=300,id=11,direction=false
FAILURE
============================================================

    // Works if replace uses of var0 with var2. Requires moving var2 decl up.

// START RECORD
// BRANCH 
// classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=true
// SEQUENCE
// var2 =  prim : char:20 : 

// var0 =  prim : java.lang.Object:null : 
// var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var2

// var3 =  prim : java.lang.Object:null : 
// var4 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var1 var2 var3 

// END RECORD


START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=false
SEQUENCE
var0 =  prim : java.lang.Object:null : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : char:20 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var1 var2 var3 

END RECORD

As source code:
java.lang.Object var0 = null;
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Character var2 = new java.lang.Character((char)' ');
java.lang.Object var3 = null;
boolean var4 = java2.util2.Collections.replaceAll((java2.util2.List)var1, (java.lang.Object)var2, (java.lang.Object)var3);

Variables: [var0:[0], var3:[0]]
      /**
       * Replaces all occurrences of one specified value in a list with another.
       * More formally, replaces with <tt>newVal</tt> each element <tt>e</tt>
       * in <tt>list</tt> such that
       * <tt>(oldVal==null ? e==null : oldVal.equals(e))</tt>.
       * (This method has no effect on the size of the list.)
       *
       * @param list the list in which replacement is to occur.
       * @param oldVal the old value to be replaced.
       * @param newVal the new value with which <tt>oldVal</tt> is to be
       *        replaced.
       * @return <tt>true</tt> if <tt>list</tt> contained one or more elements
       *         <tt>e</tt> such that
       *         <tt>(oldVal==null ?  e==null : oldVal.equals(e))</tt>.
       * @throws UnsupportedOperationException if the specified list or
       *         its list-iterator does not support the <tt>set</tt> method.
       * @since  1.4
       */
      public static boolean replaceAll(List list, Object oldVal, Object newVal) {
          boolean result = false;
          int size = list.size();
          if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {
              if (oldVal==null) {
                  for (int i=0; i<size; i++) {
                      if (list.get(i)==null) {
                          list.set(i, newVal);
                          result = true;
                      }
                  }
              } else {
                  for (int i=0; i<size; i++) {
>>                    if (oldVal.equals(list.get(i))) {
                          list.set(i, newVal);
                          result = true;
                      }
                  }
              }
          } else {
              ListIterator itr=list.listIterator();
              if (oldVal==null) {
                  for (int i=0; i<size; i++) {
                      if (itr.next()==null) {
                          itr.set(newVal);
                          result = true;
                      }
                  }
              } else {
                  for (int i=0; i<size; i++) {
                      if (oldVal.equals(itr.next())) {
                          itr.set(newVal);
                          result = true;
                      }
                  }
              }
          }
          return result;
      }


WILL TRY TO REPLACE var3 WITH var0
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=true
FAILURE
============================================================

    // Would need to create a very large list.

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=rotate,line=729,id=42,direction=true
SEQUENCE
var0 =  prim : long:-1 : 
var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
var2 =  prim : int:10 : 
var3 =  method : java2.util2.Collections.rotate(java2.util2.List,int) : var1 var2 

END RECORD

As source code:
java.lang.Long var0 = new java.lang.Long((long)-1);
java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
java.lang.Integer var2 = new java.lang.Integer((int)10);
java2.util2.Collections.rotate((java2.util2.List)var1, (int)var2);

Variables: [var1:[0]]
      /**
       * Rotates the elements in the specified list by the specified distance.
       * After calling this method, the element at index <tt>i</tt> will be
       * the element previously at index <tt>(i - distance)</tt> mod
       * <tt>list.size()</tt>, for all values of <tt>i</tt> between <tt>0</tt>
       * and <tt>list.size()-1</tt>, inclusive.  (This method has no effect on
       * the size of the list.)
       *
       * <p>For example, suppose <tt>list</tt> comprises<tt> [t, a, n, k, s]</tt>.
       * After invoking <tt>Collections.rotate(list, 1)</tt> (or
       * <tt>Collections.rotate(list, -4)</tt>), <tt>list</tt> will comprise
       * <tt>[s, t, a, n, k]</tt>.
       *
       * <p>Note that this method can usefully be applied to sublists to
       * move one or more elements within a list while preserving the
       * order of the remaining elements.  For example, the following idiom
       * moves the element at index <tt>j</tt> forward to position
       * <tt>k</tt> (which must be greater than or equal to <tt>j</tt>):
       * <pre>
       *     Collections.rotate(list.subList(j, k+1), -1);
       * </pre>
       * To make this concrete, suppose <tt>list</tt> comprises
       * <tt>[a, b, c, d, e]</tt>.  To move the element at index <tt>1</tt>
       * (<tt>b</tt>) forward two positions, perform the following invocation:
       * <pre>
       *     Collections.rotate(l.subList(1, 4), -1);
       * </pre>
       * The resulting list is <tt>[a, c, d, b, e]</tt>.
       * 
       * <p>To move more than one element forward, increase the absolute value
       * of the rotation distance.  To move elements backward, use a positive
       * shift distance.
       *
       * <p>If the specified list is small or implements the {@link
       * RandomAccess} interface, this implementation exchanges the first
       * element into the location it should go, and then repeatedly exchanges
       * the displaced element into the location it should go until a displaced
       * element is swapped into the first element.  If necessary, the process
       * is repeated on the second and successive elements, until the rotation
       * is complete.  If the specified list is large and doesn't implement the
       * <tt>RandomAccess</tt> interface, this implementation breaks the
       * list into two sublist views around index <tt>-distance mod size</tt>.
       * Then the {@link #reverse(List)} method is invoked on each sublist view,
       * and finally it is invoked on the entire list.  For a more complete
       * description of both algorithms, see Section 2.3 of Jon Bentley's
       * <i>Programming Pearls</i> (Addison-Wesley, 1986).
       *
       * @param list the list to be rotated.
       * @param distance the distance to rotate the list.  There are no
       *        constraints on this value; it may be zero, negative, or
       *        greater than <tt>list.size()</tt>.
       * @throws UnsupportedOperationException if the specified list or
       *         its list-iterator does not support the <tt>set</tt> method.
       * @since 1.4
       */
      public static void rotate(List list, int distance) {
>>        if (list instanceof RandomAccess || list.size() < ROTATE_THRESHOLD)
              rotate1(list, distance);
          else
              rotate2(list, distance);
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate,line=729,id=42,direction=false
FAILURE
============================================================

    // Not gonna work. Totate gets passed an NCopies list that is not
    // modifiable, so an exception is thrown and we never reach the
    // desired branch direction.

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=rotate1,line=745,id=46,direction=true
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : short:10 : 
var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
var5 =  method : java2.util2.Collections.synchronizedList(java2.util2.List) : var4 
var6 =  prim : int:1 : 
var7 =  method : java2.util2.Collections.rotate(java2.util2.List,int) : var5 var6 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Short var1 = new java.lang.Short((short)10);
java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
java2.util2.List var5 = java2.util2.Collections.synchronizedList((java2.util2.List)var4);
java.lang.Integer var6 = new java.lang.Integer((int)1);
java2.util2.Collections.rotate((java2.util2.List)var5, (int)var6);

Variables: [var0:[100]]
      private static void rotate1(List list, int distance) {
          int size = list.size();
          if (size == 0)
              return;
          distance = distance % size;
          if (distance < 0)
              distance += size;
          if (distance == 0)
              return;
  
>>        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
              Object displaced = list.get(cycleStart);
              int i = cycleStart;
              do {
                  i += distance;
                  if (i >= size)
                      i -= size;
                  displaced = list.set(i, displaced);
                  nMoved ++;
              } while(i != cycleStart);
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate1,line=745,id=46,direction=false
WILL TRY REPLACING var0 WITH VALUE 100
WILL TRY NEGATING var0
WILL TRY SETTING TO ZERO var0
WILL TRY ADDING 1 var0
WILL TRY SUBTRACTING 1 var0
FAILURE
============================================================

    // Not gonna work. Totate gets passed an NCopies list that is not
    // modifiable, so an exception is thrown and we never reach the
    // desired branch direction.

START RECORD
BRANCH 
classname=java2.util2.Collections,methodname=rotate1,line=750,id=47,direction=false
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : short:10 : 
var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
var5 =  method : java2.util2.Collections.synchronizedList(java2.util2.List) : var4 
var6 =  prim : int:1 : 
var7 =  method : java2.util2.Collections.rotate(java2.util2.List,int) : var5 var6 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Short var1 = new java.lang.Short((short)10);
java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
java2.util2.List var5 = java2.util2.Collections.synchronizedList((java2.util2.List)var4);
java.lang.Integer var6 = new java.lang.Integer((int)1);
java2.util2.Collections.rotate((java2.util2.List)var5, (int)var6);

Variables: [var0:[1, 100], var6:[1]]
      private static void rotate1(List list, int distance) {
          int size = list.size();
          if (size == 0)
              return;
          distance = distance % size;
          if (distance < 0)
              distance += size;
          if (distance == 0)
              return;
  
          for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
              Object displaced = list.get(cycleStart);
              int i = cycleStart;
              do {
                  i += distance;
>>                if (i >= size)
                      i -= size;
                  displaced = list.set(i, displaced);
                  nMoved ++;
              } while(i != cycleStart);
          }
      }


WILL TRY TO REPLACE var6 WITH var0
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate1,line=750,id=47,direction=true
WILL TRY REPLACING var0 WITH VALUE 1
WILL TRY REPLACING var0 WITH VALUE 100
WILL TRY NEGATING var0
WILL TRY SETTING TO ZERO var0
WILL TRY ADDING 1 var0
WILL TRY SUBTRACTING 1 var0
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate1,line=750,id=47,direction=true
WILL TRY REPLACING var6 WITH VALUE 1
WILL TRY NEGATING var6
WILL TRY SETTING TO ZERO var6
WILL TRY ADDING 1 var6
WILL TRY SUBTRACTING 1 var6
FAILURE
============================================================

    // Not gonna work because shuffle always calls nextInt with legal
    // input.

START RECORD
BRANCH 
classname=java2.util2.Random,methodname=nextInt,line=250,id=3,direction=false
SEQUENCE
var0 =  prim : int:100 : 
var1 =  prim : java.lang.Object:null : 
var2 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var1 
var3 =  method : java2.util2.Collections.shuffle(java2.util2.List) : var2 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)100);
java.lang.Object var1 = null;
java2.util2.List var2 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var1);
java2.util2.Collections.shuffle((java2.util2.List)var2);

Variables: [var0:[0]]
      /**
       * Returns a pseudorandom, uniformly distributed <tt>int</tt> value
       * between 0 (inclusive) and the specified value (exclusive), drawn from
       * this random number generator's sequence.  The general contract of
       * <tt>nextInt</tt> is that one <tt>int</tt> value in the specified range
       * is pseudorandomly generated and returned.  All <tt>n</tt> possible
       * <tt>int</tt> values are produced with (approximately) equal
       * probability.  The method <tt>nextInt(int n)</tt> is implemented by
       * class <tt>Random</tt> as follows:
       * <blockquote><pre>
       * public int nextInt(int n) {
       *     if (n<=0)
       *		throw new IllegalArgumentException("n must be positive");
       *
       *     if ((n & -n) == n)  // i.e., n is a power of 2
       *         return (int)((n * (long)next(31)) >> 31);
       *
       *     int bits, val;
       *     do {
       *         bits = next(31);
       *         val = bits % n;
       *     } while(bits - val + (n-1) < 0);
       *     return val;
       * }
       * </pre></blockquote>
       * <p>
       * The hedge "approximately" is used in the foregoing description only 
       * because the next method is only approximately an unbiased source of
       * independently chosen bits.  If it were a perfect source of randomly 
       * chosen bits, then the algorithm shown would choose <tt>int</tt> 
       * values from the stated range with perfect uniformity.
       * <p>
       * The algorithm is slightly tricky.  It rejects values that would result
       * in an uneven distribution (due to the fact that 2^31 is not divisible
       * by n). The probability of a value being rejected depends on n.  The
       * worst case is n=2^30+1, for which the probability of a reject is 1/2,
       * and the expected number of iterations before the loop terminates is 2.
       * <p>
       * The algorithm treats the case where n is a power of two specially: it
       * returns the correct number of high-order bits from the underlying
       * pseudo-random number generator.  In the absence of special treatment,
       * the correct number of <i>low-order</i> bits would be returned.  Linear
       * congruential pseudo-random number generators such as the one
       * implemented by this class are known to have short periods in the
       * sequence of values of their low-order bits.  Thus, this special case
       * greatly increases the length of the sequence of values returned by
       * successive calls to this method if n is a small power of two.
       *
       * @param n the bound on the random number to be returned.  Must be
       *	      positive.
       * @return  a pseudorandom, uniformly distributed <tt>int</tt>
       *          value between 0 (inclusive) and n (exclusive).
       * @exception IllegalArgumentException n is not positive.
       * @since 1.2
       */
  
      public int nextInt(int n) {
>>        if (n<=0)
              throw new IllegalArgumentException("n must be positive");
  
          if ((n & -n) == n)  // i.e., n is a power of 2
              return (int)((n * (long)next(31)) >> 31);
  
          int bits, val;
          do {
              bits = next(31);
              val = bits % n;
          } while(bits - val + (n-1) < 0);
          return val;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Random,methodname=nextInt,line=250,id=3,direction=true
WILL TRY REPLACING var0 WITH VALUE 0
WILL TRY NEGATING var0
WILL TRY SETTING TO ZERO var0
WILL TRY ADDING 1 var0
WILL TRY SUBTRACTING 1 var0
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=false
SEQUENCE
var0 =  cons : java2.util2.HashMap.<init>() : 
var1 =  prim : double:-1.0 : 
var2 =  prim : java.lang.String:"hi!" : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : java.lang.Object:null : 
var5 =  cons : java2.util2.HashMap.<init>() : 
var6 =  method : java2.util2.HashMap.values() : var5 
var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var6 
var8 =  method : java2.util2.AbstractMap.toString() : var0 
var9 =  prim : java.lang.String:"" : 
var10 =  method : java2.util2.HashMap.get(java.lang.Object) : var0 var9 
var11 =  cons : java2.util2.HashMap.<init>() : 
var12 =  prim : double:-1.0 : 
var13 =  prim : java.lang.String:"hi!" : 
var14 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var12 var13 
var15 =  prim : java.lang.Object:null : 
var16 =  cons : java2.util2.HashMap.<init>() : 
var17 =  method : java2.util2.HashMap.values() : var16 
var18 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var15 var17 
var19 =  method : java2.util2.AbstractMap.toString() : var11 
var20 =  prim : java.lang.Object:null : 
var21 =  method : java2.util2.HashMap.get(java.lang.Object) : var11 var20 
var22 =  method : java2.util2.HashMap.size() : var11 
var23 =  prim : long:-1 : 
var24 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var11 var23 
var25 =  method : java2.util2.HashMap.keySet() : var11 
var26 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var0 var25 

END RECORD

As source code:
java2.util2.HashMap var0 = new java2.util2.HashMap();
java.lang.Double var1 = new java.lang.Double((double)-1.0);
java.lang.String var2 = "hi!";
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = null;
java2.util2.HashMap var5 = new java2.util2.HashMap();
java2.util2.Collection var6 = var5.values();
java.lang.Object var7 = var0.put((java.lang.Object)var4, (java.lang.Object)var6);
java.lang.String var8 = var0.toString();
java.lang.String var9 = "";
java.lang.Object var10 = var0.get((java.lang.Object)var9);
java2.util2.HashMap var11 = new java2.util2.HashMap();
java.lang.Double var12 = new java.lang.Double((double)-1.0);
java.lang.String var13 = "hi!";
java.lang.Object var14 = var11.put((java.lang.Object)var12, (java.lang.Object)var13);
java.lang.Object var15 = null;
java2.util2.HashMap var16 = new java2.util2.HashMap();
java2.util2.Collection var17 = var16.values();
java.lang.Object var18 = var11.put((java.lang.Object)var15, (java.lang.Object)var17);
java.lang.String var19 = var11.toString();
java.lang.Object var20 = null;
java.lang.Object var21 = var11.get((java.lang.Object)var20);
int var22 = var11.size();
java.lang.Long var23 = new java.lang.Long((long)-1);
boolean var24 = var11.containsValue((java.lang.Object)var23);
java2.util2.Set var25 = var11.keySet();
boolean var26 = var0.containsValue((java.lang.Object)var25);

Variables: [var13:[object], var25:[object], var6:[object]]
      /**
       * Compares the specified object with this set for equality.  Returns
       * <tt>true</tt> if the given object is also a set, the two sets have
       * the same size, and every member of the given set is contained in
       * this set.  This ensures that the <tt>equals</tt> method works
       * properly across different implementations of the <tt>Set</tt>
       * interface.<p>
       *
       * This implementation first checks if the specified object is this
       * set; if so it returns <tt>true</tt>.  Then, it checks if the
       * specified object is a set whose size is identical to the size of
       * this set; if not, it it returns false.  If so, it returns
       * <tt>containsAll((Collection) o)</tt>.
       *
       * @param o Object to be compared for equality with this set.
       * @return <tt>true</tt> if the specified object is equal to this set.
       */
      public boolean equals(Object o) {
>>	if (o == this)
  	    return true;
  
  	if (!(o instanceof Set))
  	    return false;
  	Collection c = (Collection) o;
  	if (c.size() != size())
  	    return false;
          try {
              return containsAll(c);
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
      }


WILL TRY TO REPLACE var13 WITH var6
WILL TRY TO REPLACE var25 WITH var6
WILL TRY TO REPLACE var25 WITH var13
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=true
SEQUENCE
var0 =  cons : java2.util2.HashMap.<init>() : 
var1 =  prim : double:-1.0 : 
var2 =  prim : java.lang.String:"hi!" : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : java.lang.Object:null : 
var5 =  cons : java2.util2.HashMap.<init>() : 
var6 =  method : java2.util2.HashMap.values() : var5 
var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var6 
var8 =  method : java2.util2.AbstractMap.toString() : var0 
var9 =  prim : java.lang.String:"" : 
var10 =  method : java2.util2.HashMap.get(java.lang.Object) : var0 var9 
var11 =  cons : java2.util2.HashMap.<init>() : 
var12 =  prim : double:-1.0 : 
var13 =  prim : java.lang.String:"hi!" : 
var14 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var12 var13 
var15 =  prim : java.lang.Object:null : 
var16 =  cons : java2.util2.HashMap.<init>() : 
var17 =  method : java2.util2.HashMap.values() : var16 
var18 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var15 var17 
var19 =  method : java2.util2.AbstractMap.toString() : var11 
var20 =  prim : java.lang.Object:null : 
var21 =  method : java2.util2.HashMap.get(java.lang.Object) : var11 var20 
var22 =  method : java2.util2.HashMap.size() : var11 
var23 =  prim : long:-1 : 
var24 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var11 var23 
var25 =  method : java2.util2.HashMap.keySet() : var11 
var26 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var0 var25 

END RECORD

As source code:
java2.util2.HashMap var0 = new java2.util2.HashMap();
java.lang.Double var1 = new java.lang.Double((double)-1.0);
java.lang.String var2 = "hi!";
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = null;
java2.util2.HashMap var5 = new java2.util2.HashMap();
java2.util2.Collection var6 = var5.values();
java.lang.Object var7 = var0.put((java.lang.Object)var4, (java.lang.Object)var6);
java.lang.String var8 = var0.toString();
java.lang.String var9 = "";
java.lang.Object var10 = var0.get((java.lang.Object)var9);
java2.util2.HashMap var11 = new java2.util2.HashMap();
java.lang.Double var12 = new java.lang.Double((double)-1.0);
java.lang.String var13 = "hi!";
java.lang.Object var14 = var11.put((java.lang.Object)var12, (java.lang.Object)var13);
java.lang.Object var15 = null;
java2.util2.HashMap var16 = new java2.util2.HashMap();
java2.util2.Collection var17 = var16.values();
java.lang.Object var18 = var11.put((java.lang.Object)var15, (java.lang.Object)var17);
java.lang.String var19 = var11.toString();
java.lang.Object var20 = null;
java.lang.Object var21 = var11.get((java.lang.Object)var20);
int var22 = var11.size();
java.lang.Long var23 = new java.lang.Long((long)-1);
boolean var24 = var11.containsValue((java.lang.Object)var23);
java2.util2.Set var25 = var11.keySet();
boolean var26 = var0.containsValue((java.lang.Object)var25);

Variables: [var13:[0], var6:[0]]
      /**
       * Compares the specified object with this set for equality.  Returns
       * <tt>true</tt> if the given object is also a set, the two sets have
       * the same size, and every member of the given set is contained in
       * this set.  This ensures that the <tt>equals</tt> method works
       * properly across different implementations of the <tt>Set</tt>
       * interface.<p>
       *
       * This implementation first checks if the specified object is this
       * set; if so it returns <tt>true</tt>.  Then, it checks if the
       * specified object is a set whose size is identical to the size of
       * this set; if not, it it returns false.  If so, it returns
       * <tt>containsAll((Collection) o)</tt>.
       *
       * @param o Object to be compared for equality with this set.
       * @return <tt>true</tt> if the specified object is equal to this set.
       */
      public boolean equals(Object o) {
  	if (o == this)
  	    return true;
  
>>	if (!(o instanceof Set))
  	    return false;
  	Collection c = (Collection) o;
  	if (c.size() != size())
  	    return false;
          try {
              return containsAll(c);
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
      }


WILL TRY TO REPLACE var13 WITH var6
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
FAILURE
============================================================

START RECORD
BRANCH 
classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=false
SEQUENCE
var0 =  cons : java2.util2.HashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : char:20 : 
var5 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var0 var4 

END RECORD

As source code:
java2.util2.HashMap var0 = new java2.util2.HashMap();
java.lang.Object var1 = null;
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Character var4 = new java.lang.Character((char)' ');
boolean var5 = var0.containsValue((java.lang.Object)var4);

Variables: [var2:[0], var3:[0], var1:[0]]
      /**
       * Returns <tt>true</tt> if this map maps one or more keys to the
       * specified value.
       *
       * @param value value whose presence in this map is to be tested.
       * @return <tt>true</tt> if this map maps one or more keys to the
       *         specified value.
       */
      public boolean containsValue(Object value) {
  	if (value == null) 
              return containsNullValue();
  
  	Entry tab[] = table;
          for (int i = 0; i < tab.length ; i++)
              for (Entry e = tab[i] ; e != null ; e = e.next)
>>                if (value.equals(e.value))
                      return true;
  	return false;
      }


WILL TRY TO REPLACE var2 WITH var1
WILL TRY TO REPLACE var3 WITH var1
WILL TRY TO REPLACE var3 WITH var2
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=true
FAILURE
============================================================

    // We'll need another sequence. Hashtables do not allow null
    // values, but we need a map that allows a null value.

START RECORD
BRANCH 
classname=java2.util2.Hashtable,methodname=equals,line=733,id=34,direction=false
SEQUENCE
var0 =  cons : java2.util2.Hashtable.<init>() : 
var1 =  prim : long:10 : 
var2 =  prim : short:0 : 
var3 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  cons : java2.util2.Hashtable.<init>() : 
var5 =  prim : long:10 : 
var6 =  prim : short:0 : 
var7 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var4 var5 var6 
var8 =  method : java2.util2.Hashtable.values() : var4 
var9 =  method : java2.util2.Hashtable.equals(java.lang.Object) : var0 var4 

END RECORD

As source code:
java2.util2.Hashtable var0 = new java2.util2.Hashtable();
java.lang.Long var1 = new java.lang.Long((long)10);
java.lang.Short var2 = new java.lang.Short((short)0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java2.util2.Hashtable var4 = new java2.util2.Hashtable();
java.lang.Long var5 = new java.lang.Long((long)10);
java.lang.Short var6 = new java.lang.Short((short)0);
java.lang.Object var7 = var4.put((java.lang.Object)var5, (java.lang.Object)var6);
java2.util2.Collection var8 = var4.values();
boolean var9 = var0.equals((java.lang.Object)var4);

Variables: [var6:[null]]
      /**
       * Compares the specified Object with this Map for equality,
       * as per the definition in the Map interface.
       *
       * @param  o object to be compared for equality with this Hashtable
       * @return true if the specified Object is equal to this Map.
       * @see Map#equals(Object)
       * @since 1.2
       */
      public synchronized boolean equals(Object o) {
  	if (o == this)
  	    return true;
  
  	if (!(o instanceof Map))
  	    return false;
  	Map t = (Map) o;
  	if (t.size() != size())
  	    return false;
  
          try {
              Iterator i = entrySet().iterator();
              while (i.hasNext()) {
                  Map.Entry e = (Map.Entry) i.next();
                  Object key = e.getKey();
                  Object value = e.getValue();
>>                if (value == null) {
                      if (!(t.get(key)==null && t.containsKey(key)))
                          return false;
                  } else {
                      if (!value.equals(t.get(key)))
                          return false;
                  }
              }
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
  
  	return true;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Hashtable,methodname=equals,line=733,id=34,direction=true
Primitive value...
FAILURE

============================================================

    // need to make var1 a Map (but not an IdentityHashMap).
    // If we knew about the branch (o instanceof Map), this
    // could be arranged.

START RECORD
BRANCH 
classname=java2.util2.IdentityHashMap,methodname=equals,line=629,id=36,direction=false
SEQUENCE
var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
var1 =  prim : float:100.0 : 
var2 =  method : java2.util2.IdentityHashMap.equals(java.lang.Object) : var0 var1 

END RECORD

As source code:
java2.util2.IdentityHashMap var0 = new java2.util2.IdentityHashMap();
java.lang.Float var1 = new java.lang.Float((float)100.0);
boolean var2 = var0.equals((java.lang.Object)var1);

Variables: [var1:[0]]
      /**
       * Compares the specified object with this map for equality.  Returns
       * <tt>true</tt> if the given object is also a map and the two maps
       * represent identical object-reference mappings.  More formally, this
       * map is equal to another map <tt>m</tt> if and only if
       * map <tt>this.entrySet().equals(m.entrySet())</tt>.
       *
       * <p><b>Owing to the reference-equality-based semantics of this map it is
       * possible that the symmetry and transitivity requirements of the
       * <tt>Object.equals</tt> contract may be violated if this map is compared
       * to a normal map.  However, the <tt>Object.equals</tt> contract is
       * guaranteed to hold among <tt>IdentityHashMap</tt> instances.</b>
       *
       * @param  o object to be compared for equality with this map.
       * @return <tt>true</tt> if the specified object is equal to this map.
       * @see Object#equals(Object)
       */
      public boolean equals(Object o) {
          if (o == this) {
              return true;
          } else if (o instanceof IdentityHashMap) {
              IdentityHashMap m = (IdentityHashMap) o;
              if (m.size() != size)
                  return false;
  
              Object[] tab = m.table;
              for (int i = 0; i < tab.length; i+=2) {
                  Object k = tab[i];
                  if (k != null && !containsMapping(k, tab[i + 1]))
                      return false;
              }
              return true;
>>        } else if (o instanceof Map) {
              Map m = (Map)o;
              return entrySet().equals(m.entrySet());
          } else {
              return false;  // o is not a Map
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=equals,line=629,id=36,direction=true
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=false
SEQUENCE
var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:1.0 : 
var3 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : char:20 : 
var5 =  cons : java2.util2.IdentityHashMap.<init>() : 
var6 =  method : java2.util2.IdentityHashMap.keySet() : var5 
var7 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var8 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 

END RECORD

As source code:
java2.util2.IdentityHashMap var0 = new java2.util2.IdentityHashMap();
java.lang.Object var1 = null;
java.lang.Double var2 = new java.lang.Double((double)1.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Character var4 = new java.lang.Character((char)' ');
java2.util2.IdentityHashMap var5 = new java2.util2.IdentityHashMap();
java2.util2.Set var6 = var5.keySet();
java.lang.Object var7 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
java2.util2.IdentityHashMap var8 = new java2.util2.IdentityHashMap((java2.util2.Map)var0);

Variables: [var7:[null], var1:[null], var3:[null]]
      /**
       * Resize the table to hold given capacity.
       *
       * @param newCapacity the new capacity, must be a power of two.
       */
      private void resize(int newCapacity) {
          // assert (newCapacity & -newCapacity) == newCapacity; // power of 2
          int newLength = newCapacity * 2; 
  
          Object[] oldTable = table;
          int oldLength = oldTable.length;
          if (oldLength == 2*MAXIMUM_CAPACITY) { // can't expand any further
              if (threshold == MAXIMUM_CAPACITY-1)
                  throw new IllegalStateException("Capacity exhausted.");
              threshold = MAXIMUM_CAPACITY-1;  // Gigantic map!
              return;
          }
          if (oldLength >= newLength)
              return;
  
          Object[] newTable = new Object[newLength];
          threshold = newLength / 3;
  
          for (int j = 0; j < oldLength; j += 2) {
              Object key = oldTable[j];
              if (key != null) {
                  Object value = oldTable[j+1];
                  oldTable[j] = null;
                  oldTable[j+1] = null;
                  int i = hash(key, newLength);
>>                while (newTable[i] != null) 
                      i = nextKeyIndex(i, newLength);
                  newTable[i] = key;
                  newTable[i + 1] = value;
              }
          }
          table = newTable;
      }


WILL TRY TO REPLACE var3 WITH var1
WILL TRY TO REPLACE var7 WITH var1
WILL TRY TO REPLACE var7 WITH var3
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=true
REPLACING ALL USES OF var7 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:1.0 : 
var3 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : char:20 : 
var5 =  cons : java2.util2.IdentityHashMap.<init>() : 
var6 =  method : java2.util2.IdentityHashMap.keySet() : var5 
var7 =  prim : java.lang.Object:null : 
var8 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var9 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=true
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var1 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
var1 =  prim : byte:-1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  prim : double:1.0 : 
var4 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var3 
var5 =  prim : char:20 : 
var6 =  cons : java2.util2.IdentityHashMap.<init>() : 
var7 =  method : java2.util2.IdentityHashMap.keySet() : var6 
var8 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
var9 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:1.0 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : char:20 : 
var6 =  cons : java2.util2.IdentityHashMap.<init>() : 
var7 =  method : java2.util2.IdentityHashMap.keySet() : var6 
var8 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
var9 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=true
SEQUENCE
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:-1.0 : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : java.lang.Object:null : 
var5 =  prim : java.lang.Object:null : 
var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var7 =  cons : java2.util2.LinkedHashMap.<init>() : 
var8 =  prim : double:0.0 : 
var9 =  prim : int:100 : 
var10 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var7 var8 var9 
var11 =  method : java2.util2.HashMap.entrySet() : var7 
var12 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var7 

END RECORD

As source code:
java2.util2.LinkedHashMap var0 = new java2.util2.LinkedHashMap();
java.lang.Object var1 = null;
java.lang.Double var2 = new java.lang.Double((double)-1.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = null;
java.lang.Object var5 = null;
java.lang.Object var6 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
java2.util2.LinkedHashMap var7 = new java2.util2.LinkedHashMap();
java.lang.Double var8 = new java.lang.Double((double)0.0);
java.lang.Integer var9 = new java.lang.Integer((int)100);
java.lang.Object var10 = var7.put((java.lang.Object)var8, (java.lang.Object)var9);
java2.util2.Set var11 = var7.entrySet();
boolean var12 = var0.equals((java.lang.Object)var7);

Variables: [var1:[null], var3:[null], var5:[null], var4:[null], var10:[null]]
      /**
       * Compares the specified object with this map for equality.  Returns
       * <tt>true</tt> if the given object is also a map and the two maps
       * represent the same mappings.  More formally, two maps <tt>t1</tt> and
       * <tt>t2</tt> represent the same mappings if
       * <tt>t1.keySet().equals(t2.keySet())</tt> and for every key <tt>k</tt>
       * in <tt>t1.keySet()</tt>, <tt> (t1.get(k)==null ? t2.get(k)==null :
       * t1.get(k).equals(t2.get(k))) </tt>.  This ensures that the
       * <tt>equals</tt> method works properly across different implementations
       * of the map interface.<p>
       *
       * This implementation first checks if the specified object is this map;
       * if so it returns <tt>true</tt>.  Then, it checks if the specified
       * object is a map whose size is identical to the size of this set; if
       * not, it it returns <tt>false</tt>.  If so, it iterates over this map's
       * <tt>entrySet</tt> collection, and checks that the specified map
       * contains each mapping that this map contains.  If the specified map
       * fails to contain such a mapping, <tt>false</tt> is returned.  If the
       * iteration completes, <tt>true</tt> is returned.
       *
       * @param o object to be compared for equality with this map.
       * @return <tt>true</tt> if the specified object is equal to this map.
       */
      public boolean equals(Object o) {
  	if (o == this)
  	    return true;
  
  	if (!(o instanceof Map))
  	    return false;
  	Map t = (Map) o;
  	if (t.size() != size())
  	    return false;
  
          try {
              Iterator i = entrySet().iterator();
              while (i.hasNext()) {
                  Entry e = (Entry) i.next();
                  Object key = e.getKey();
                  Object value = e.getValue();
                  if (value == null) {
>>                    if (!(t.get(key)==null && t.containsKey(key)))
                          return false;
                  } else {
                      if (!value.equals(t.get(key)))
                          return false;
                  }
              }
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
  
  	return true;
      }


WILL TRY TO REPLACE var3 WITH var1
WILL TRY TO REPLACE var4 WITH var1
WILL TRY TO REPLACE var5 WITH var1
WILL TRY TO REPLACE var10 WITH var1
WILL TRY TO REPLACE var4 WITH var3
WILL TRY TO REPLACE var5 WITH var3
WILL TRY TO REPLACE var10 WITH var3
WILL TRY TO REPLACE var5 WITH var4
WILL TRY TO REPLACE var10 WITH var4
WILL TRY TO REPLACE var10 WITH var5
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var1 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : byte:-1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  prim : double:-1.0 : 
var4 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var3 
var5 =  prim : java.lang.Object:null : 
var6 =  prim : java.lang.Object:null : 
var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
var9 =  prim : double:0.0 : 
var10 =  prim : int:100 : 
var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
var12 =  method : java2.util2.HashMap.entrySet() : var8 
var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:-1.0 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : java.lang.Object:null : 
var6 =  prim : java.lang.Object:null : 
var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
var9 =  prim : double:0.0 : 
var10 =  prim : int:100 : 
var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
var12 =  method : java2.util2.HashMap.entrySet() : var8 
var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var5 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:-1.0 : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : java.lang.Object:null : 
var5 =  prim : byte:-1 : 
var6 =  prim : java.lang.Object:null : 
var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
var9 =  prim : double:0.0 : 
var10 =  prim : int:100 : 
var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
var12 =  method : java2.util2.HashMap.entrySet() : var8 
var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var4 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:-1.0 : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : byte:-1 : 
var5 =  prim : java.lang.Object:null : 
var6 =  prim : java.lang.Object:null : 
var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var6 
var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
var9 =  prim : double:0.0 : 
var10 =  prim : int:100 : 
var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
var12 =  method : java2.util2.HashMap.entrySet() : var8 
var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
REPLACING ALL USES OF var10 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:-1.0 : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : java.lang.Object:null : 
var5 =  prim : java.lang.Object:null : 
var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var7 =  cons : java2.util2.LinkedHashMap.<init>() : 
var8 =  prim : double:0.0 : 
var9 =  prim : int:100 : 
var10 =  prim : java.lang.Object:null : 
var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var7 var8 var9 
var12 =  method : java2.util2.HashMap.entrySet() : var7 
var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var7 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=false
SEQUENCE
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:0.0 : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:10 : 
var5 =  cons : java.lang.Object.<init>() : 
var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var7 =  method : java2.util2.HashMap.isEmpty() : var0 
var8 =  prim : java.lang.Object:null : 
var9 =  method : java2.util2.LinkedHashMap.get(java.lang.Object) : var0 var8 
var10 =  cons : java2.util2.LinkedHashMap.<init>() : 
var11 =  prim : java.lang.Object:null : 
var12 =  prim : double:-1.0 : 
var13 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var11 var12 
var14 =  prim : java.lang.Object:null : 
var15 =  prim : java.lang.Object:null : 
var16 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var14 var15 
var17 =  method : java2.util2.HashMap.keySet() : var10 
var18 =  method : java2.util2.LinkedHashMap.containsValue(java.lang.Object) : var0 var17 

END RECORD

As source code:
java2.util2.LinkedHashMap var0 = new java2.util2.LinkedHashMap();
java.lang.Object var1 = null;
java.lang.Double var2 = new java.lang.Double((double)0.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)10);
java.lang.Object var5 = new java.lang.Object();
java.lang.Object var6 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
boolean var7 = var0.isEmpty();
java.lang.Object var8 = null;
java.lang.Object var9 = var0.get((java.lang.Object)var8);
java2.util2.LinkedHashMap var10 = new java2.util2.LinkedHashMap();
java.lang.Object var11 = null;
java.lang.Double var12 = new java.lang.Double((double)-1.0);
java.lang.Object var13 = var10.put((java.lang.Object)var11, (java.lang.Object)var12);
java.lang.Object var14 = null;
java.lang.Object var15 = null;
java.lang.Object var16 = var10.put((java.lang.Object)var14, (java.lang.Object)var15);
java2.util2.Set var17 = var10.keySet();
boolean var18 = var0.containsValue((java.lang.Object)var17);

Variables: [var9:[object], var2:[object], var17:[object], var5:[object]]
      /**
       * Compares the specified object with this set for equality.  Returns
       * <tt>true</tt> if the given object is also a set, the two sets have
       * the same size, and every member of the given set is contained in
       * this set.  This ensures that the <tt>equals</tt> method works
       * properly across different implementations of the <tt>Set</tt>
       * interface.<p>
       *
       * This implementation first checks if the specified object is this
       * set; if so it returns <tt>true</tt>.  Then, it checks if the
       * specified object is a set whose size is identical to the size of
       * this set; if not, it it returns false.  If so, it returns
       * <tt>containsAll((Collection) o)</tt>.
       *
       * @param o Object to be compared for equality with this set.
       * @return <tt>true</tt> if the specified object is equal to this set.
       */
      public boolean equals(Object o) {
>>	if (o == this)
  	    return true;
  
  	if (!(o instanceof Set))
  	    return false;
  	Collection c = (Collection) o;
  	if (c.size() != size())
  	    return false;
          try {
              return containsAll(c);
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
      }


WILL TRY TO REPLACE var5 WITH var2
WILL TRY TO REPLACE var9 WITH var2
WILL TRY TO REPLACE var17 WITH var2
WILL TRY TO REPLACE var9 WITH var5
WILL TRY TO REPLACE var17 WITH var5
WILL TRY TO REPLACE var17 WITH var9
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=true
SEQUENCE
var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
var1 =  prim : java.lang.Object:null : 
var2 =  prim : double:0.0 : 
var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:10 : 
var5 =  cons : java.lang.Object.<init>() : 
var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
var7 =  method : java2.util2.HashMap.isEmpty() : var0 
var8 =  prim : java.lang.Object:null : 
var9 =  method : java2.util2.LinkedHashMap.get(java.lang.Object) : var0 var8 
var10 =  cons : java2.util2.LinkedHashMap.<init>() : 
var11 =  prim : java.lang.Object:null : 
var12 =  prim : double:-1.0 : 
var13 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var11 var12 
var14 =  prim : java.lang.Object:null : 
var15 =  prim : java.lang.Object:null : 
var16 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var14 var15 
var17 =  method : java2.util2.HashMap.keySet() : var10 
var18 =  method : java2.util2.LinkedHashMap.containsValue(java.lang.Object) : var0 var17 

END RECORD

As source code:
java2.util2.LinkedHashMap var0 = new java2.util2.LinkedHashMap();
java.lang.Object var1 = null;
java.lang.Double var2 = new java.lang.Double((double)0.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)10);
java.lang.Object var5 = new java.lang.Object();
java.lang.Object var6 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
boolean var7 = var0.isEmpty();
java.lang.Object var8 = null;
java.lang.Object var9 = var0.get((java.lang.Object)var8);
java2.util2.LinkedHashMap var10 = new java2.util2.LinkedHashMap();
java.lang.Object var11 = null;
java.lang.Double var12 = new java.lang.Double((double)-1.0);
java.lang.Object var13 = var10.put((java.lang.Object)var11, (java.lang.Object)var12);
java.lang.Object var14 = null;
java.lang.Object var15 = null;
java.lang.Object var16 = var10.put((java.lang.Object)var14, (java.lang.Object)var15);
java2.util2.Set var17 = var10.keySet();
boolean var18 = var0.containsValue((java.lang.Object)var17);

Variables: [var9:[0], var2:[0], var5:[0]]
      /**
       * Compares the specified object with this set for equality.  Returns
       * <tt>true</tt> if the given object is also a set, the two sets have
       * the same size, and every member of the given set is contained in
       * this set.  This ensures that the <tt>equals</tt> method works
       * properly across different implementations of the <tt>Set</tt>
       * interface.<p>
       *
       * This implementation first checks if the specified object is this
       * set; if so it returns <tt>true</tt>.  Then, it checks if the
       * specified object is a set whose size is identical to the size of
       * this set; if not, it it returns false.  If so, it returns
       * <tt>containsAll((Collection) o)</tt>.
       *
       * @param o Object to be compared for equality with this set.
       * @return <tt>true</tt> if the specified object is equal to this set.
       */
      public boolean equals(Object o) {
  	if (o == this)
  	    return true;
  
>>	if (!(o instanceof Set))
  	    return false;
  	Collection c = (Collection) o;
  	if (c.size() != size())
  	    return false;
          try {
              return containsAll(c);
          } catch(ClassCastException unused)   {
              return false;
          } catch(NullPointerException unused) {
              return false;
          }
      }


WILL TRY TO REPLACE var5 WITH var2
WILL TRY TO REPLACE var9 WITH var2
WILL TRY TO REPLACE var9 WITH var5
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.SubList,methodname=listIterator,line=785,id=6,direction=false
SEQUENCE
var0 =  cons : java2.util2.LinkedList.<init>() : 
var1 =  prim : double:1.0 : 
var2 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var0 var1 
var3 =  prim : int:0 : 
var4 =  cons : java2.util2.LinkedList.<init>() : 
var5 =  prim : double:1.0 : 
var6 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var4 var5 
var7 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var0 var3 var4 
var8 =  prim : int:0 : 
var9 =  prim : java.lang.Object:null : 
var10 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var4 var8 var9 
var11 =  cons : java2.util2.LinkedList.<init>() : 
var12 =  method : java2.util2.AbstractSequentialList.iterator() : var11 
var13 =  method : java2.util2.LinkedList.addLast(java.lang.Object) : var4 var12 
var14 =  prim : java.lang.Object:null : 
var15 =  method : java2.util2.LinkedList.contains(java.lang.Object) : var4 var14 
var16 =  method : java2.util2.AbstractSequentialList.iterator() : var4 
var17 =  cons : java2.util2.LinkedList.<init>(java2.util2.Collection) : var4 
var18 =  method : java2.util2.AbstractCollection.isEmpty() : var4 
var19 =  cons : java2.util2.LinkedList.<init>() : 
var20 =  prim : double:1.0 : 
var21 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var19 var20 
var22 =  prim : int:0 : 
var23 =  cons : java2.util2.LinkedList.<init>() : 
var24 =  prim : double:1.0 : 
var25 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var23 var24 
var26 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var19 var22 var23 
var27 =  prim : int:0 : 
var28 =  prim : java.lang.Object:null : 
var29 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var23 var27 var28 
var30 =  prim : int:0 : 
var31 =  cons : java.lang.Object.<init>() : 
var32 =  method : java2.util2.LinkedList.add(int,java.lang.Object) : var23 var30 var31 
var33 =  method : java2.util2.AbstractCollection.toString() : var23 
var34 =  prim : java.lang.Object:null : 
var35 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var23 var34 
var36 =  method : java2.util2.AbstractCollection.toString() : var23 
var37 =  cons : java2.util2.LinkedList.<init>() : 
var38 =  prim : double:1.0 : 
var39 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var37 var38 
var40 =  prim : int:0 : 
var41 =  cons : java2.util2.LinkedList.<init>() : 
var42 =  prim : double:1.0 : 
var43 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var41 var42 
var44 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var37 var40 var41 
var45 =  prim : int:0 : 
var46 =  prim : java.lang.Object:null : 
var47 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var41 var45 var46 
var48 =  prim : int:0 : 
var49 =  method : java2.util2.LinkedList.listIterator(int) : var41 var48 
var50 =  method : java2.util2.LinkedList.indexOf(java.lang.Object) : var23 var49 
var51 =  prim : int:0 : 
var52 =  prim : java.lang.Object:null : 
var53 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var23 var51 var52 
var54 =  method : java2.util2.LinkedList.addAll(java2.util2.Collection) : var4 var23 
var55 =  cons : java2.util2.LinkedList.<init>() : 
var56 =  prim : double:1.0 : 
var57 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var55 var56 
var58 =  prim : int:0 : 
var59 =  cons : java2.util2.LinkedList.<init>() : 
var60 =  prim : double:1.0 : 
var61 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var59 var60 
var62 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var55 var58 var59 
var63 =  prim : int:0 : 
var64 =  prim : java.lang.Object:null : 
var65 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var59 var63 var64 
var66 =  prim : int:0 : 
var67 =  cons : java.lang.Object.<init>() : 
var68 =  method : java2.util2.LinkedList.add(int,java.lang.Object) : var59 var66 var67 
var69 =  method : java2.util2.AbstractCollection.toString() : var59 
var70 =  prim : java.lang.Object:null : 
var71 =  method : java2.util2.LinkedList.lastIndexOf(java.lang.Object) : var59 var70 
var72 =  prim : int:0 : 
var73 =  prim : int:0 : 
var74 =  method : java2.util2.AbstractList.subList(int,int) : var59 var72 var73 
var75 =  method : java2.util2.LinkedList.addAll(java2.util2.Collection) : var4 var74 

END RECORD

As source code:
java2.util2.LinkedList var0 = new java2.util2.LinkedList();
java.lang.Double var1 = new java.lang.Double((double)1.0);
var0.addFirst((java.lang.Object)var1);
java.lang.Integer var3 = new java.lang.Integer((int)0);
java2.util2.LinkedList var4 = new java2.util2.LinkedList();
java.lang.Double var5 = new java.lang.Double((double)1.0);
var4.addFirst((java.lang.Object)var5);
boolean var7 = var0.addAll((int)var3, (java2.util2.Collection)var4);
java.lang.Integer var8 = new java.lang.Integer((int)0);
java.lang.Object var9 = null;
java.lang.Object var10 = var4.set((int)var8, (java.lang.Object)var9);
java2.util2.LinkedList var11 = new java2.util2.LinkedList();
java2.util2.Iterator var12 = var11.iterator();
var4.addLast((java.lang.Object)var12);
java.lang.Object var14 = null;
boolean var15 = var4.contains((java.lang.Object)var14);
java2.util2.Iterator var16 = var4.iterator();
java2.util2.LinkedList var17 = new java2.util2.LinkedList((java2.util2.Collection)var4);
boolean var18 = var4.isEmpty();
java2.util2.LinkedList var19 = new java2.util2.LinkedList();
java.lang.Double var20 = new java.lang.Double((double)1.0);
var19.addFirst((java.lang.Object)var20);
java.lang.Integer var22 = new java.lang.Integer((int)0);
java2.util2.LinkedList var23 = new java2.util2.LinkedList();
java.lang.Double var24 = new java.lang.Double((double)1.0);
var23.addFirst((java.lang.Object)var24);
boolean var26 = var19.addAll((int)var22, (java2.util2.Collection)var23);
java.lang.Integer var27 = new java.lang.Integer((int)0);
java.lang.Object var28 = null;
java.lang.Object var29 = var23.set((int)var27, (java.lang.Object)var28);
java.lang.Integer var30 = new java.lang.Integer((int)0);
java.lang.Object var31 = new java.lang.Object();
var23.add((int)var30, (java.lang.Object)var31);
java.lang.String var33 = var23.toString();
java.lang.Object var34 = null;
var23.addFirst((java.lang.Object)var34);
java.lang.String var36 = var23.toString();
java2.util2.LinkedList var37 = new java2.util2.LinkedList();
java.lang.Double var38 = new java.lang.Double((double)1.0);
var37.addFirst((java.lang.Object)var38);
java.lang.Integer var40 = new java.lang.Integer((int)0);
java2.util2.LinkedList var41 = new java2.util2.LinkedList();
java.lang.Double var42 = new java.lang.Double((double)1.0);
var41.addFirst((java.lang.Object)var42);
boolean var44 = var37.addAll((int)var40, (java2.util2.Collection)var41);
java.lang.Integer var45 = new java.lang.Integer((int)0);
java.lang.Object var46 = null;
java.lang.Object var47 = var41.set((int)var45, (java.lang.Object)var46);
java.lang.Integer var48 = new java.lang.Integer((int)0);
java2.util2.ListIterator var49 = var41.listIterator((int)var48);
int var50 = var23.indexOf((java.lang.Object)var49);
java.lang.Integer var51 = new java.lang.Integer((int)0);
java.lang.Object var52 = null;
java.lang.Object var53 = var23.set((int)var51, (java.lang.Object)var52);
boolean var54 = var4.addAll((java2.util2.Collection)var23);
java2.util2.LinkedList var55 = new java2.util2.LinkedList();
java.lang.Double var56 = new java.lang.Double((double)1.0);
var55.addFirst((java.lang.Object)var56);
java.lang.Integer var58 = new java.lang.Integer((int)0);
java2.util2.LinkedList var59 = new java2.util2.LinkedList();
java.lang.Double var60 = new java.lang.Double((double)1.0);
var59.addFirst((java.lang.Object)var60);
boolean var62 = var55.addAll((int)var58, (java2.util2.Collection)var59);
java.lang.Integer var63 = new java.lang.Integer((int)0);
java.lang.Object var64 = null;
java.lang.Object var65 = var59.set((int)var63, (java.lang.Object)var64);
java.lang.Integer var66 = new java.lang.Integer((int)0);
java.lang.Object var67 = new java.lang.Object();
var59.add((int)var66, (java.lang.Object)var67);
java.lang.String var69 = var59.toString();
java.lang.Object var70 = null;
int var71 = var59.lastIndexOf((java.lang.Object)var70);
java.lang.Integer var72 = new java.lang.Integer((int)0);
java.lang.Integer var73 = new java.lang.Integer((int)0);
java2.util2.List var74 = var59.subList((int)var72, (int)var73);
boolean var75 = var4.addAll((java2.util2.Collection)var74);

Variables: [var72:[0], var73:[0]]
      public ListIterator listIterator(final int index) {
          checkForComodification();
>>        if (index<0 || index>size)
              throw new IndexOutOfBoundsException(
                  "Index: "+index+", Size: "+size);
  
          return new ListIterator() {
              private ListIterator i = l.listIterator(index+offset);
  
              public boolean hasNext() {
                  return nextIndex() < size;
              }
  
              public Object next() {
                  if (hasNext())
                      return i.next();
                  else
                      throw new NoSuchElementException();
              }
  
              public boolean hasPrevious() {
                  return previousIndex() >= 0;
              }
  
              public Object previous() {
                  if (hasPrevious())
                      return i.previous();
                  else
                      throw new NoSuchElementException();
              }
  
              public int nextIndex() {
                  return i.nextIndex() - offset;
              }
  
              public int previousIndex() {
                  return i.previousIndex() - offset;
              }
  
              public void remove() {
                  i.remove();
                  expectedModCount = l.modCount;
                  size--;
                  modCount++;
              }
  
              public void set(Object o) {
                  i.set(o);
              }
  
              public void add(Object o) {
                  i.add(o);
                  expectedModCount = l.modCount;
                  size++;
                  modCount++;
              }
          };
      }


WILL TRY TO REPLACE var73 WITH var72
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.SubList,methodname=listIterator,line=785,id=6,direction=true
WILL TRY REPLACING var72 WITH VALUE 0
WILL TRY NEGATING var72
WILL TRY SETTING TO ZERO var72
WILL TRY ADDING 1 var72
WILL TRY SUBTRACTING 1 var72
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.SubList,methodname=listIterator,line=785,id=6,direction=true
WILL TRY REPLACING var73 WITH VALUE 0
WILL TRY NEGATING var73
WILL TRY SETTING TO ZERO var73
WILL TRY ADDING 1 var73
WILL TRY SUBTRACTING 1 var73
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.Observable,methodname=addObserver,line=65,id=0,direction=true
SEQUENCE
var0 =  cons : java2.util2.Observable.<init>() : 
var1 =  method : java2.util2.Observable.hasChanged() : var0 
var2 =  prim : java2.util2.Observer:null : 
var3 =  method : java2.util2.Observable.addObserver(java2.util2.Observer) : var0 var2 

END RECORD

As source code:
java2.util2.Observable var0 = new java2.util2.Observable();
boolean var1 = var0.hasChanged();
java2.util2.Observer var2 = null;
var0.addObserver((java2.util2.Observer)var2);

Variables: [var2:[null]]
      /**
       * Adds an observer to the set of observers for this object, provided 
       * that it is not the same as some observer already in the set. 
       * The order in which notifications will be delivered to multiple 
       * observers is not specified. See the class comment.
       *
       * @param   o   an observer to be added.
       * @throws NullPointerException   if the parameter o is null.
       */
      public synchronized void addObserver(Observer o) {
>>        if (o == null)
              throw new NullPointerException();
  	if (!obs.contains(o)) {
  	    obs.addElement(o);
  	}
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Observable,methodname=addObserver,line=65,id=0,direction=false
NO COMPONENTS.
FAILURE
============================================================

    // Will never work, because we don't know how to create an observer.

START RECORD
BRANCH 
classname=java2.util2.Vector,methodname=indexOf,line=357,id=7,direction=true
SEQUENCE
var0 =  cons : java2.util2.Observable.<init>() : 
var1 =  prim : java2.util2.Observer:null : 
var2 =  method : java2.util2.Observable.deleteObserver(java2.util2.Observer) : var0 var1 

END RECORD

As source code:
java2.util2.Observable var0 = new java2.util2.Observable();
java2.util2.Observer var1 = null;
var0.deleteObserver((java2.util2.Observer)var1);

Variables: [var1:[null]]
      /**
       * Searches for the first occurence of the given argument, beginning 
       * the search at <code>index</code>, and testing for equality using 
       * the <code>equals</code> method. 
       *
       * @param   elem    an object.
       * @param   index   the non-negative index to start searching from.
       * @return  the index of the first occurrence of the object argument in
       *          this vector at position <code>index</code> or later in the
       *          vector, that is, the smallest value <tt>k</tt> such that 
       *          <tt>elem.equals(elementData[k]) && (k &gt;= index)</tt> is 
       *          <tt>true</tt>; returns <code>-1</code> if the object is not 
       *          found. (Returns <code>-1</code> if <tt>index</tt> &gt;= the
       *          current size of this <tt>Vector</tt>.)
       * @exception  IndexOutOfBoundsException  if <tt>index</tt> is negative.
       * @see     Object#equals(Object)
       */
      public synchronized int indexOf(Object elem, int index) {
>>	if (elem == null) {
  	    for (int i = index ; i < elementCount ; i++)
  		if (elementData[i]==null)
  		    return i;
  	} else {
  	    for (int i = index ; i < elementCount ; i++)
  		if (elem.equals(elementData[i]))
  		    return i;
  	}
  	return -1;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Vector,methodname=indexOf,line=357,id=7,direction=false
NO COMPONENTS.
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1587,id=80,direction=true
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  method : java2.util2.TreeMap.clone() : var0 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Character var1 = new java.lang.Character((char)'#');
java.lang.Float var2 = new java.lang.Float((float)10.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = var0.clone();

Variables: [var3:[null]]
      /**
       * Recursive "helper method" that does the real work of the
       * of the previous method.  Identically named parameters have
       * identical definitions.  Additional parameters are documented below.
       * It is assumed that the comparator and size fields of the TreeMap are
       * already set prior to calling this method.  (It ignores both fields.)
       *
       * @param level the current level of tree. Initial call should be 0.
       * @param lo the first element index of this subtree. Initial should be 0.
       * @param hi the last element index of this subtree.  Initial should be
       *              size-1.
       * @param redLevel the level at which nodes should be red. 
       *        Must be equal to computeRedLevel for tree of this size.
       */
      private static Entry buildFromSorted(int level, int lo, int hi,
                                           int redLevel,
                                           Iterator it, 
                                           java.io.ObjectInputStream str,
                                           Object defaultVal) 
          throws  java.io.IOException, ClassNotFoundException {
          /*
           * Strategy: The root is the middlemost element. To get to it, we
           * have to first recursively construct the entire left subtree,
           * so as to grab all of its elements. We can then proceed with right
           * subtree. 
           *
           * The lo and hi arguments are the minimum and maximum
           * indices to pull out of the iterator or stream for current subtree.
           * They are not actually indexed, we just proceed sequentially,
           * ensuring that items are extracted in corresponding order.
           */
  
          if (hi < lo) return null;
  
          int mid = (lo + hi) / 2;
          
          Entry left  = null;
          if (lo < mid) 
              left = buildFromSorted(level+1, lo, mid - 1, redLevel,
                                     it, str, defaultVal);
          
          // extract key and/or value from iterator or stream
          Object key;
          Object value;
          if (it != null) { // use iterator
>>            if (defaultVal==null) {
                  Map.Entry entry = (Map.Entry) it.next();
                  key = entry.getKey();
                  value = entry.getValue();
              } else {
                  key = it.next();
                  value = defaultVal;
              }
          } else { // use stream
              key = str.readObject();
              value = (defaultVal != null ? defaultVal : str.readObject());
          }
  
          Entry middle =  new Entry(key, value, null);
          
          // color nodes in non-full bottommost level red
          if (level == redLevel)
              middle.color = RED;
          
          if (left != null) { 
              middle.left = left; 
              left.parent = middle; 
          }
          
          if (mid < hi) {
              Entry right = buildFromSorted(level+1, mid+1, hi, redLevel,
                                            it, str, defaultVal);
              middle.right = right;
              right.parent = middle;
          }
          
          return middle;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1587,id=80,direction=false
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  method : java2.util2.TreeMap.clone() : var0 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1606,id=82,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  method : java2.util2.TreeMap.clone() : var0 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Character var1 = new java.lang.Character((char)'#');
java.lang.Float var2 = new java.lang.Float((float)10.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = var0.clone();

Variables: [var3:[null]]
      /**
       * Recursive "helper method" that does the real work of the
       * of the previous method.  Identically named parameters have
       * identical definitions.  Additional parameters are documented below.
       * It is assumed that the comparator and size fields of the TreeMap are
       * already set prior to calling this method.  (It ignores both fields.)
       *
       * @param level the current level of tree. Initial call should be 0.
       * @param lo the first element index of this subtree. Initial should be 0.
       * @param hi the last element index of this subtree.  Initial should be
       *              size-1.
       * @param redLevel the level at which nodes should be red. 
       *        Must be equal to computeRedLevel for tree of this size.
       */
      private static Entry buildFromSorted(int level, int lo, int hi,
                                           int redLevel,
                                           Iterator it, 
                                           java.io.ObjectInputStream str,
                                           Object defaultVal) 
          throws  java.io.IOException, ClassNotFoundException {
          /*
           * Strategy: The root is the middlemost element. To get to it, we
           * have to first recursively construct the entire left subtree,
           * so as to grab all of its elements. We can then proceed with right
           * subtree. 
           *
           * The lo and hi arguments are the minimum and maximum
           * indices to pull out of the iterator or stream for current subtree.
           * They are not actually indexed, we just proceed sequentially,
           * ensuring that items are extracted in corresponding order.
           */
  
          if (hi < lo) return null;
  
          int mid = (lo + hi) / 2;
          
          Entry left  = null;
          if (lo < mid) 
              left = buildFromSorted(level+1, lo, mid - 1, redLevel,
                                     it, str, defaultVal);
          
          // extract key and/or value from iterator or stream
          Object key;
          Object value;
          if (it != null) { // use iterator
              if (defaultVal==null) {
                  Map.Entry entry = (Map.Entry) it.next();
                  key = entry.getKey();
                  value = entry.getValue();
              } else {
                  key = it.next();
                  value = defaultVal;
              }
          } else { // use stream
              key = str.readObject();
              value = (defaultVal != null ? defaultVal : str.readObject());
          }
  
          Entry middle =  new Entry(key, value, null);
          
          // color nodes in non-full bottommost level red
          if (level == redLevel)
              middle.color = RED;
          
>>        if (left != null) { 
              middle.left = left; 
              left.parent = middle; 
          }
          
          if (mid < hi) {
              Entry right = buildFromSorted(level+1, mid+1, hi, redLevel,
                                            it, str, defaultVal);
              middle.right = right;
              right.parent = middle;
          }
          
          return middle;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1606,id=82,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  method : java2.util2.TreeMap.clone() : var0 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:1 : 
var5 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Integer var1 = new java.lang.Integer((int)1);
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)1);
java.lang.Object var5 = var0.remove((java.lang.Object)var4);

Variables: [var3:[null], var5:[null], var2:[null]]
      /**
       * Delete node p, and then rebalance the tree.
       */
  
      private void deleteEntry(Entry p) {
          decrementSize();
  
          // If strictly internal, copy successor's element to p and then make p
          // point to successor.
>>        if (p.left != null && p.right != null) {
              Entry s = successor (p);
              p.key = s.key;       
              p.value = s.value;  
              p = s;
          } // p has 2 children
  
          // Start fixup at replacement node, if it exists.
          Entry replacement = (p.left != null ? p.left : p.right);
  
          if (replacement != null) {
              // Link replacement to parent
              replacement.parent = p.parent;
              if (p.parent == null)
                  root = replacement;
              else if (p == p.parent.left)
                  p.parent.left  = replacement;
              else
                  p.parent.right = replacement;
  
              // Null out links so they are OK to use by fixAfterDeletion.
              p.left = p.right = p.parent = null;
  
              // Fix replacement
              if (p.color == BLACK)
                  fixAfterDeletion(replacement);
          } else if (p.parent == null) { // return if we are the only node.
              root = null;
          } else { //  No children. Use self as phantom replacement and unlink.
              if (p.color == BLACK)
                  fixAfterDeletion(p);
  
              if (p.parent != null) {
                  if (p == p.parent.left)
                      p.parent.left = null;
                  else if (p == p.parent.right)
                      p.parent.right = null;
                  p.parent = null;
              }
          }
      }


WILL TRY TO REPLACE var3 WITH var2
WILL TRY TO REPLACE var5 WITH var2
WILL TRY TO REPLACE var5 WITH var3
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : int:1 : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
REPLACING ALL USES OF var5 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:1 : 
var5 =  prim : java.lang.Object:null : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var2 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : byte:-1 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : int:1 : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:1 : 
var5 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Integer var1 = new java.lang.Integer((int)1);
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)1);
java.lang.Object var5 = var0.remove((java.lang.Object)var4);

Variables: [var2:[null], var5:[null], var3:[null]]
      /**
       * Delete node p, and then rebalance the tree.
       */
  
      private void deleteEntry(Entry p) {
          decrementSize();
  
          // If strictly internal, copy successor's element to p and then make p
          // point to successor.
          if (p.left != null && p.right != null) {
              Entry s = successor (p);
              p.key = s.key;       
              p.value = s.value;  
              p = s;
          } // p has 2 children
  
          // Start fixup at replacement node, if it exists.
          Entry replacement = (p.left != null ? p.left : p.right);
  
>>        if (replacement != null) {
              // Link replacement to parent
              replacement.parent = p.parent;
              if (p.parent == null)
                  root = replacement;
              else if (p == p.parent.left)
                  p.parent.left  = replacement;
              else
                  p.parent.right = replacement;
  
              // Null out links so they are OK to use by fixAfterDeletion.
              p.left = p.right = p.parent = null;
  
              // Fix replacement
              if (p.color == BLACK)
                  fixAfterDeletion(replacement);
          } else if (p.parent == null) { // return if we are the only node.
              root = null;
          } else { //  No children. Use self as phantom replacement and unlink.
              if (p.color == BLACK)
                  fixAfterDeletion(p);
  
              if (p.parent != null) {
                  if (p == p.parent.left)
                      p.parent.left = null;
                  else if (p == p.parent.right)
                      p.parent.right = null;
                  p.parent = null;
              }
          }
      }


WILL TRY TO REPLACE var3 WITH var2
WILL TRY TO REPLACE var5 WITH var2
WILL TRY TO REPLACE var5 WITH var3
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=true
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var2 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : byte:-1 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : int:1 : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=true
REPLACING ALL USES OF var5 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:1 : 
var5 =  prim : java.lang.Object:null : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : int:1 : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=true
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:1 : 
var5 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Integer var1 = new java.lang.Integer((int)1);
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)1);
java.lang.Object var5 = var0.remove((java.lang.Object)var4);

Variables: [var2:[null], var5:[null], var3:[null]]
      /**
       * Delete node p, and then rebalance the tree.
       */
  
      private void deleteEntry(Entry p) {
          decrementSize();
  
          // If strictly internal, copy successor's element to p and then make p
          // point to successor.
          if (p.left != null && p.right != null) {
              Entry s = successor (p);
              p.key = s.key;       
              p.value = s.value;  
              p = s;
          } // p has 2 children
  
          // Start fixup at replacement node, if it exists.
          Entry replacement = (p.left != null ? p.left : p.right);
  
          if (replacement != null) {
              // Link replacement to parent
              replacement.parent = p.parent;
              if (p.parent == null)
                  root = replacement;
              else if (p == p.parent.left)
                  p.parent.left  = replacement;
              else
                  p.parent.right = replacement;
  
              // Null out links so they are OK to use by fixAfterDeletion.
              p.left = p.right = p.parent = null;
  
              // Fix replacement
              if (p.color == BLACK)
                  fixAfterDeletion(replacement);
>>        } else if (p.parent == null) { // return if we are the only node.
              root = null;
          } else { //  No children. Use self as phantom replacement and unlink.
              if (p.color == BLACK)
                  fixAfterDeletion(p);
  
              if (p.parent != null) {
                  if (p == p.parent.left)
                      p.parent.left = null;
                  else if (p == p.parent.right)
                      p.parent.right = null;
                  p.parent = null;
              }
          }
      }


WILL TRY TO REPLACE var3 WITH var2
WILL TRY TO REPLACE var5 WITH var2
WILL TRY TO REPLACE var5 WITH var3
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=false
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var2 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : byte:-1 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : int:1 : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=false
REPLACING ALL USES OF var5 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : int:1 : 
var5 =  prim : java.lang.Object:null : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=false
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  prim : int:1 : 
var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=firstEntry,line=1180,id=36,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  method : java2.util2.TreeMap.firstKey() : var0 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Character var1 = new java.lang.Character((char)'#');
java.lang.Float var2 = new java.lang.Float((float)10.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = var0.firstKey();

Variables: [var3:[null]]
      /**
       * Returns the first Entry in the TreeMap (according to the TreeMap's
       * key-sort function).  Returns null if the TreeMap is empty.
       */
      private Entry firstEntry() {
          Entry p = root;
          if (p != null)
>>            while (p.left != null)
                  p = p.left;
          return p;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=firstEntry,line=1180,id=36,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  method : java2.util2.TreeMap.firstKey() : var0 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=lastEntry,line=1192,id=38,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:61 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  method : java2.util2.TreeMap.lastKey() : var0 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Character var1 = new java.lang.Character((char)'a');
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = var0.lastKey();

Variables: [var2:[null], var3:[null]]
      /**
       * Returns the last Entry in the TreeMap (according to the TreeMap's
       * key-sort function).  Returns null if the TreeMap is empty.
       */
      private Entry lastEntry() {
          Entry p = root;
          if (p != null)
>>            while (p.right != null)
                  p = p.right;
          return p;
      }


WILL TRY TO REPLACE var3 WITH var2
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=lastEntry,line=1192,id=38,direction=true
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var2 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:61 : 
var2 =  prim : byte:-1 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  method : java2.util2.TreeMap.lastKey() : var0 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=lastEntry,line=1192,id=38,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:61 : 
var2 =  prim : java.lang.Object:null : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  method : java2.util2.TreeMap.lastKey() : var0 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=putAll,line=316,id=3,direction=true
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:61 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  cons : java2.util2.TreeMap.<init>(java2.util2.Map) : var0 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Character var1 = new java.lang.Character((char)'a');
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java2.util2.TreeMap var4 = new java2.util2.TreeMap((java2.util2.Map)var0);

Variables: [var3:[object], var2:[object]]
      /**
       * Copies all of the mappings from the specified map to this map.  These
       * mappings replace any mappings that this map had for any of the keys
       * currently in the specified map.
       *
       * @param     map mappings to be stored in this map.
       * @throws    ClassCastException class of a key or value in the specified
       *                   map prevents it from being stored in this map.
       * 
       * @throws NullPointerException if the given map is <tt>null</tt> or
       *         this map does not permit <tt>null</tt> keys and a 
       *         key in the specified map is <tt>null</tt>.
       */
      public void putAll(Map map) {
          int mapSize = map.size();
          if (size==0 && mapSize!=0 && map instanceof SortedMap) {
              Comparator c = ((SortedMap)map).comparator();
>>            if (c == comparator || (c != null && c.equals(comparator))) {
                ++modCount;
                try {
                    buildFromSorted(mapSize, map.entrySet().iterator(),
                                    null, null);
                } catch (java.io.IOException cannotHappen) {
                } catch (ClassNotFoundException cannotHappen) {
                }
                return;
              }
          }
          super.putAll(map);
      }


WILL TRY TO REPLACE var3 WITH var2
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=putAll,line=316,id=3,direction=false
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=putAll,line=316,id=3,direction=false
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=successor,line=1203,id=40,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  method : java2.util2.TreeMap.clone() : var0 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Character var1 = new java.lang.Character((char)'#');
java.lang.Float var2 = new java.lang.Float((float)10.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = var0.clone();

Variables: [var3:[null]]
      /**
       * Returns the successor of the specified Entry, or null if no such.
       */
      private Entry successor(Entry t) {
          if (t == null)
              return null;
>>        else if (t.right != null) {
              Entry p = t.right;
              while (p.left != null)
                  p = p.left;
              return p;
          } else {
              Entry p = t.parent;
              Entry ch = t;
              while (p != null && ch == p.right) {
                  ch = p;
                  p = p.parent;
              }
              return p;
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=successor,line=1203,id=40,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  method : java2.util2.TreeMap.clone() : var0 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=successor,line=1211,id=42,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  method : java2.util2.TreeMap.clone() : var0 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Character var1 = new java.lang.Character((char)'#');
java.lang.Float var2 = new java.lang.Float((float)10.0);
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Object var4 = var0.clone();

Variables: [var3:[null]]
      /**
       * Returns the successor of the specified Entry, or null if no such.
       */
      private Entry successor(Entry t) {
          if (t == null)
              return null;
          else if (t.right != null) {
              Entry p = t.right;
              while (p.left != null)
                  p = p.left;
              return p;
          } else {
              Entry p = t.parent;
              Entry ch = t;
>>            while (p != null && ch == p.right) {
                  ch = p;
                  p = p.parent;
              }
              return p;
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=successor,line=1211,id=42,direction=true
REPLACING ALL USES OF var3 WITH var0
NEW SEQUENCE: 
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : char:23 : 
var2 =  prim : float:10.0 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var5 =  method : java2.util2.TreeMap.clone() : var0 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=false
SEQUENCE
var0 =  cons : java2.util2.TreeMap.<init>() : 
var1 =  prim : int:1 : 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
var4 =  prim : boolean:false : 
var5 =  method : java2.util2.TreeMap.containsValue(java.lang.Object) : var0 var4 

END RECORD

As source code:
java2.util2.TreeMap var0 = new java2.util2.TreeMap();
java.lang.Integer var1 = new java.lang.Integer((int)1);
java.lang.Object var2 = null;
java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
java.lang.Boolean var4 = new java.lang.Boolean((boolean)false);
boolean var5 = var0.containsValue((java.lang.Object)var4);

Variables: [var4:[0], var3:[0], var2:[0]]
      private boolean valueSearchNonNull(Entry n, Object value) {
          // Check this node for the value
>>        if (value.equals(n.value))
              return true;
  
          // Check left and right subtrees for value
          return (n.left  != null && valueSearchNonNull(n.left, value)) ||
                 (n.right != null && valueSearchNonNull(n.right, value));
      }


WILL TRY TO REPLACE var3 WITH var2
WILL TRY TO REPLACE var4 WITH var2
WILL TRY TO REPLACE var4 WITH var3
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=true
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=true
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.AbstractMap,methodname=keySet,line=371,id=22,direction=true
SEQUENCE
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : int:0 : 
var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
var4 =  prim : char:20 : 
var5 =  method : java2.util2.TreeSet.headSet(java.lang.Object) : var1 var4 

END RECORD

As source code:
java2.util2.Comparator var0 = null;
java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
java.lang.Integer var2 = new java.lang.Integer((int)0);
boolean var3 = var1.add((java.lang.Object)var2);
java.lang.Character var4 = new java.lang.Character((char)' ');
java2.util2.SortedSet var5 = var1.headSet((java.lang.Object)var4);

Variables: [var0:[null]]
      /**
       * Returns a Set view of the keys contained in this map.  The Set is
       * backed by the map, so changes to the map are reflected in the Set,
       * and vice-versa.  (If the map is modified while an iteration over
       * the Set is in progress, the results of the iteration are undefined.)
       * The Set supports element removal, which removes the corresponding entry
       * from the map, via the Iterator.remove, Set.remove,  removeAll
       * retainAll, and clear operations.  It does not support the add or
       * addAll operations.<p>
       *
       * This implementation returns a Set that subclasses
       * AbstractSet.  The subclass's iterator method returns a "wrapper
       * object" over this map's entrySet() iterator.  The size method delegates
       * to this map's size method and the contains method delegates to this
       * map's containsKey method.<p>
       *
       * The Set is created the first time this method is called,
       * and returned in response to all subsequent calls.  No synchronization
       * is performed, so there is a slight chance that multiple calls to this
       * method will not all return the same Set.
       *
       * @return a Set view of the keys contained in this map.
       */
      public Set keySet() {
>>	if (keySet == null) {
  	    keySet = new AbstractSet() {
  		public Iterator iterator() {
  		    return new Iterator() {
  			private Iterator i = entrySet().iterator();
  
  			public boolean hasNext() {
  			    return i.hasNext();
  			}
  
  			public Object next() {
  			    return ((Entry)i.next()).getKey();
  			}
  
  			public void remove() {
  			    i.remove();
  			}
                      };
  		}
  
  		public int size() {
  		    return AbstractMap.this.size();
  		}
  
  		public boolean contains(Object k) {
  		    return AbstractMap.this.containsKey(k);
  		}
  	    };
  	}
  	return keySet;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=keySet,line=371,id=22,direction=false
WILL USE:
var0 =  method : java2.util2.Collections.reverseOrder() : 


REPLACING ALL USES OF var0 WITH var0
NEW SEQUENCE: 
var0 =  method : java2.util2.Collections.reverseOrder() : 
var1 =  prim : java2.util2.Comparator:null : 
var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var3 =  prim : int:0 : 
var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
var5 =  prim : char:20 : 
var6 =  method : java2.util2.TreeSet.headSet(java.lang.Object) : var2 var5 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=false
SEQUENCE
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : int:0 : 
var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
var4 =  prim : int:-1 : 
var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
var6 =  prim : java2.util2.Comparator:null : 
var7 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var6 
var8 =  method : java2.util2.AbstractCollection.retainAll(java2.util2.Collection) : var1 var7 

END RECORD

As source code:
java2.util2.Comparator var0 = null;
java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
java.lang.Integer var2 = new java.lang.Integer((int)0);
boolean var3 = var1.add((java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)-1);
boolean var5 = var1.add((java.lang.Object)var4);
java2.util2.Comparator var6 = null;
java2.util2.TreeSet var7 = new java2.util2.TreeSet((java2.util2.Comparator)var6);
boolean var8 = var1.retainAll((java2.util2.Collection)var7);

Variables: [var0:[null], var6:[null]]
      /**
       * Delete node p, and then rebalance the tree.
       */
  
      private void deleteEntry(Entry p) {
          decrementSize();
  
          // If strictly internal, copy successor's element to p and then make p
          // point to successor.
>>        if (p.left != null && p.right != null) {
              Entry s = successor (p);
              p.key = s.key;       
              p.value = s.value;  
              p = s;
          } // p has 2 children
  
          // Start fixup at replacement node, if it exists.
          Entry replacement = (p.left != null ? p.left : p.right);
  
          if (replacement != null) {
              // Link replacement to parent
              replacement.parent = p.parent;
              if (p.parent == null)
                  root = replacement;
              else if (p == p.parent.left)
                  p.parent.left  = replacement;
              else
                  p.parent.right = replacement;
  
              // Null out links so they are OK to use by fixAfterDeletion.
              p.left = p.right = p.parent = null;
  
              // Fix replacement
              if (p.color == BLACK)
                  fixAfterDeletion(replacement);
          } else if (p.parent == null) { // return if we are the only node.
              root = null;
          } else { //  No children. Use self as phantom replacement and unlink.
              if (p.color == BLACK)
                  fixAfterDeletion(p);
  
              if (p.parent != null) {
                  if (p == p.parent.left)
                      p.parent.left = null;
                  else if (p == p.parent.right)
                      p.parent.right = null;
                  p.parent = null;
              }
          }
      }


WILL TRY TO REPLACE var6 WITH var0
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
WILL USE:
var0 =  method : java2.util2.Collections.reverseOrder() : 


REPLACING ALL USES OF var0 WITH var0
NEW SEQUENCE: 
var0 =  method : java2.util2.Collections.reverseOrder() : 
var1 =  prim : java2.util2.Comparator:null : 
var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var3 =  prim : int:0 : 
var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
var5 =  prim : int:-1 : 
var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 
var7 =  prim : java2.util2.Comparator:null : 
var8 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var7 
var9 =  method : java2.util2.AbstractCollection.retainAll(java2.util2.Collection) : var2 var8 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
WILL USE:
var0 =  method : java2.util2.Collections.reverseOrder() : 


REPLACING ALL USES OF var6 WITH var0
NEW SEQUENCE: 
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : int:0 : 
var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
var4 =  prim : int:-1 : 
var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
var6 =  method : java2.util2.Collections.reverseOrder() : 
var7 =  prim : java2.util2.Comparator:null : 
var8 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var6 
var9 =  method : java2.util2.AbstractCollection.retainAll(java2.util2.Collection) : var1 var8 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=put,line=467,id=22,direction=false
SEQUENCE
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : int:0 : 
var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
var4 =  prim : int:-1 : 
var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 

END RECORD

As source code:
java2.util2.Comparator var0 = null;
java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
java.lang.Integer var2 = new java.lang.Integer((int)0);
boolean var3 = var1.add((java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)-1);
boolean var5 = var1.add((java.lang.Object)var4);

Variables: [var0:[null]]
      /**
       * Associates the specified value with the specified key in this map.
       * If the map previously contained a mapping for this key, the old
       * value is replaced.
       *
       * @param key key with which the specified value is to be associated.
       * @param value value to be associated with the specified key.
       * 
       * @return previous value associated with specified key, or <tt>null</tt>
       *         if there was no mapping for key.  A <tt>null</tt> return can
       *         also indicate that the map previously associated <tt>null</tt>
       *         with the specified key.
       * @throws    ClassCastException key cannot be compared with the keys
       *            currently in the map.
       * @throws NullPointerException key is <tt>null</tt> and this map uses
       *         natural order, or its comparator does not tolerate
       *         <tt>null</tt> keys.
       */
      public Object put(Object key, Object value) {
          Entry t = root;
  
          if (t == null) {
              incrementSize();
              root = new Entry(key, value, null);
              return null;
         }
  
          while (true) {
              int cmp = compare(key, t.key);
              if (cmp == 0) {
                  return t.setValue(value);
              } else if (cmp < 0) {
>>                if (t.left != null) {
                      t = t.left;
                  } else {
                      incrementSize();
                      t.left = new Entry(key, value, t);
                      fixAfterInsertion(t.left);
                      return null;
                  }
              } else { // cmp > 0
                  if (t.right != null) {
                      t = t.right;
                  } else {
                      incrementSize();
                      t.right = new Entry(key, value, t);
                      fixAfterInsertion(t.right);
                      return null;
                  }
              }
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=put,line=467,id=22,direction=true
WILL USE:
var0 =  method : java2.util2.Collections.reverseOrder() : 


REPLACING ALL USES OF var0 WITH var0
NEW SEQUENCE: 
var0 =  method : java2.util2.Collections.reverseOrder() : 
var1 =  prim : java2.util2.Comparator:null : 
var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var3 =  prim : int:0 : 
var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
var5 =  prim : int:-1 : 
var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=put,line=476,id=23,direction=false
SEQUENCE
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : int:0 : 
var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
var4 =  prim : int:-1 : 
var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
var6 =  prim : int:10 : 
var7 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var6 

END RECORD

As source code:
java2.util2.Comparator var0 = null;
java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
java.lang.Integer var2 = new java.lang.Integer((int)0);
boolean var3 = var1.add((java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)-1);
boolean var5 = var1.add((java.lang.Object)var4);
java.lang.Integer var6 = new java.lang.Integer((int)10);
boolean var7 = var1.add((java.lang.Object)var6);

Variables: [var0:[null]]
      /**
       * Associates the specified value with the specified key in this map.
       * If the map previously contained a mapping for this key, the old
       * value is replaced.
       *
       * @param key key with which the specified value is to be associated.
       * @param value value to be associated with the specified key.
       * 
       * @return previous value associated with specified key, or <tt>null</tt>
       *         if there was no mapping for key.  A <tt>null</tt> return can
       *         also indicate that the map previously associated <tt>null</tt>
       *         with the specified key.
       * @throws    ClassCastException key cannot be compared with the keys
       *            currently in the map.
       * @throws NullPointerException key is <tt>null</tt> and this map uses
       *         natural order, or its comparator does not tolerate
       *         <tt>null</tt> keys.
       */
      public Object put(Object key, Object value) {
          Entry t = root;
  
          if (t == null) {
              incrementSize();
              root = new Entry(key, value, null);
              return null;
         }
  
          while (true) {
              int cmp = compare(key, t.key);
              if (cmp == 0) {
                  return t.setValue(value);
              } else if (cmp < 0) {
                  if (t.left != null) {
                      t = t.left;
                  } else {
                      incrementSize();
                      t.left = new Entry(key, value, t);
                      fixAfterInsertion(t.left);
                      return null;
                  }
              } else { // cmp > 0
>>                if (t.right != null) {
                      t = t.right;
                  } else {
                      incrementSize();
                      t.right = new Entry(key, value, t);
                      fixAfterInsertion(t.right);
                      return null;
                  }
              }
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=put,line=476,id=23,direction=true
WILL USE:
var0 =  method : java2.util2.Collections.reverseOrder() : 


REPLACING ALL USES OF var0 WITH var0
NEW SEQUENCE: 
var0 =  method : java2.util2.Collections.reverseOrder() : 
var1 =  prim : java2.util2.Comparator:null : 
var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var3 =  prim : int:0 : 
var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
var5 =  prim : int:-1 : 
var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 
var7 =  prim : int:10 : 
var8 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var7 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=remove,line=505,id=24,direction=true
SEQUENCE
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.TreeSet.remove(java.lang.Object) : var1 var2 

END RECORD

As source code:
java2.util2.Comparator var0 = null;
java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
java.lang.Object var2 = null;
boolean var3 = var1.remove((java.lang.Object)var2);

Variables: [var2:[null], var0:[null]]
      /**
       * Removes the mapping for this key from this TreeMap if present.
       *
       * @param  key key for which mapping should be removed
       * @return previous value associated with specified key, or <tt>null</tt>
       *         if there was no mapping for key.  A <tt>null</tt> return can
       *         also indicate that the map previously associated
       *         <tt>null</tt> with the specified key.
       * 
       * @throws    ClassCastException key cannot be compared with the keys
       *            currently in the map.
       * @throws NullPointerException key is <tt>null</tt> and this map uses
       *         natural order, or its comparator does not tolerate
       *         <tt>null</tt> keys.
       */
      public Object remove(Object key) {
          Entry p = getEntry(key);
>>        if (p == null)
              return null;
  
          Object oldValue = p.value;
          deleteEntry(p);
          return oldValue;
      }


WILL TRY TO REPLACE var2 WITH var0
GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=remove,line=505,id=24,direction=false
WILL USE:
var0 =  prim : byte:-1 : 


REPLACING ALL USES OF var2 WITH var0
NEW SEQUENCE: 
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : byte:-1 : 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeSet.remove(java.lang.Object) : var1 var2 

GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=remove,line=505,id=24,direction=false
WILL USE:
var0 =  method : java2.util2.Collections.reverseOrder() : 


REPLACING ALL USES OF var0 WITH var0
NEW SEQUENCE: 
var0 =  method : java2.util2.Collections.reverseOrder() : 
var1 =  prim : java2.util2.Comparator:null : 
var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var3 =  prim : java.lang.Object:null : 
var4 =  method : java2.util2.TreeSet.remove(java.lang.Object) : var2 var3 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeMap,methodname=successor,line=1205,id=41,direction=false
SEQUENCE
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : int:0 : 
var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
var4 =  prim : int:-1 : 
var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
var6 =  prim : int:10 : 
var7 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var6 
var8 =  method : java2.util2.AbstractCollection.toString() : var1 

END RECORD

As source code:
java2.util2.Comparator var0 = null;
java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
java.lang.Integer var2 = new java.lang.Integer((int)0);
boolean var3 = var1.add((java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)-1);
boolean var5 = var1.add((java.lang.Object)var4);
java.lang.Integer var6 = new java.lang.Integer((int)10);
boolean var7 = var1.add((java.lang.Object)var6);
java.lang.String var8 = var1.toString();

Variables: [var0:[null]]
      /**
       * Returns the successor of the specified Entry, or null if no such.
       */
      private Entry successor(Entry t) {
          if (t == null)
              return null;
          else if (t.right != null) {
              Entry p = t.right;
>>            while (p.left != null)
                  p = p.left;
              return p;
          } else {
              Entry p = t.parent;
              Entry ch = t;
              while (p != null && ch == p.right) {
                  ch = p;
                  p = p.parent;
              }
              return p;
          }
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=successor,line=1205,id=41,direction=true
WILL USE:
var0 =  method : java2.util2.Collections.reverseOrder() : 


REPLACING ALL USES OF var0 WITH var0
NEW SEQUENCE: 
var0 =  method : java2.util2.Collections.reverseOrder() : 
var1 =  prim : java2.util2.Comparator:null : 
var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var3 =  prim : int:0 : 
var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
var5 =  prim : int:-1 : 
var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 
var7 =  prim : int:10 : 
var8 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var7 
var9 =  method : java2.util2.AbstractCollection.toString() : var2 

FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.TreeSet,methodname=addAll,line=250,id=1,direction=true
SEQUENCE
var0 =  prim : java2.util2.Comparator:null : 
var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
var2 =  prim : int:0 : 
var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
var4 =  cons : java2.util2.TreeSet.<init>(java2.util2.Collection) : var1 

END RECORD

As source code:
java2.util2.Comparator var0 = null;
java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
java.lang.Integer var2 = new java.lang.Integer((int)0);
boolean var3 = var1.add((java.lang.Object)var2);
java2.util2.TreeSet var4 = new java2.util2.TreeSet((java2.util2.Collection)var1);

Variables: [var0:[object]]
      /**
       * Adds all of the elements in the specified collection to this set.
       *
       * @param c elements to be added
       * @return <tt>true</tt> if this set changed as a result of the call.
       *
       * @throws ClassCastException if the elements provided cannot be compared
       *		  with the elements currently in the set.
       * @throws NullPointerException of the specified collection is null.
       */
      public boolean addAll(Collection c) {
          // Use linear-time version if applicable
          if (m.size()==0 && c.size() > 0 && c instanceof SortedSet && 
              m instanceof TreeMap) {
              SortedSet set = (SortedSet)c;
              TreeMap map = (TreeMap)m;
              Comparator cc = set.comparator();
              Comparator mc = map.comparator();
>>            if (cc==mc || (cc != null && cc.equals(mc))) {
                  map.addAllForTreeSet(set, PRESENT);
                  return true;
              }
          }
          return super.addAll(c);
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeSet,methodname=addAll,line=250,id=1,direction=false
FAILURE
============================================================
START RECORD
BRANCH 
classname=java2.util2.Vector,methodname=addAll,line=908,id=35,direction=true
SEQUENCE
var0 =  prim : int:0 : 
var1 =  cons : java2.util2.Vector.<init>(int) : var0 
var2 =  prim : java.lang.Object:null : 
var3 =  method : java2.util2.Vector.addElement(java.lang.Object) : var1 var2 
var4 =  prim : int:0 : 
var5 =  cons : java2.util2.Vector.<init>(int) : var4 
var6 =  method : java2.util2.Vector.addElement(java.lang.Object) : var1 var5 
var7 =  prim : int:0 : 
var8 =  cons : java2.util2.Vector.<init>(int) : var7 
var9 =  prim : int:0 : 
var10 =  prim : double:10.0 : 
var11 =  method : java2.util2.Vector.add(int,java.lang.Object) : var8 var9 var10 
var12 =  method : java2.util2.Vector.elements() : var8 
var13 =  prim : int:0 : 
var14 =  method : java2.util2.Vector.insertElementAt(java.lang.Object,int) : var1 var12 var13 
var15 =  prim : int:1 : 
var16 =  method : java2.util2.Vector.ensureCapacity(int) : var1 var15 
var17 =  method : java2.util2.Vector.size() : var1 
var18 =  prim : java.lang.Object:null : 
var19 =  method : java2.util2.Vector.removeElement(java.lang.Object) : var1 var18 
var20 =  method : java2.util2.Vector.capacity() : var1 
var21 =  prim : int:0 : 
var22 =  prim : int:0 : 
var23 =  cons : java2.util2.Vector.<init>(int) : var22 
var24 =  prim : java.lang.Object:null : 
var25 =  method : java2.util2.Vector.addElement(java.lang.Object) : var23 var24 
var26 =  prim : int:0 : 
var27 =  cons : java2.util2.Vector.<init>(int) : var26 
var28 =  method : java2.util2.Vector.addElement(java.lang.Object) : var23 var27 
var29 =  prim : int:0 : 
var30 =  cons : java2.util2.Vector.<init>(int) : var29 
var31 =  prim : int:0 : 
var32 =  prim : double:10.0 : 
var33 =  method : java2.util2.Vector.add(int,java.lang.Object) : var30 var31 var32 
var34 =  method : java2.util2.Vector.elements() : var30 
var35 =  prim : int:0 : 
var36 =  method : java2.util2.Vector.insertElementAt(java.lang.Object,int) : var23 var34 var35 
var37 =  prim : int:1 : 
var38 =  method : java2.util2.Vector.ensureCapacity(int) : var23 var37 
var39 =  method : java2.util2.Vector.size() : var23 
var40 =  prim : java.lang.Object:null : 
var41 =  method : java2.util2.Vector.removeElement(java.lang.Object) : var23 var40 
var42 =  method : java2.util2.Vector.addAll(int,java2.util2.Collection) : var1 var21 var23 

END RECORD

As source code:
java.lang.Integer var0 = new java.lang.Integer((int)0);
java2.util2.Vector var1 = new java2.util2.Vector((int)var0);
java.lang.Object var2 = null;
var1.addElement((java.lang.Object)var2);
java.lang.Integer var4 = new java.lang.Integer((int)0);
java2.util2.Vector var5 = new java2.util2.Vector((int)var4);
var1.addElement((java.lang.Object)var5);
java.lang.Integer var7 = new java.lang.Integer((int)0);
java2.util2.Vector var8 = new java2.util2.Vector((int)var7);
java.lang.Integer var9 = new java.lang.Integer((int)0);
java.lang.Double var10 = new java.lang.Double((double)10.0);
var8.add((int)var9, (java.lang.Object)var10);
java2.util2.Enumeration var12 = var8.elements();
java.lang.Integer var13 = new java.lang.Integer((int)0);
var1.insertElementAt((java.lang.Object)var12, (int)var13);
java.lang.Integer var15 = new java.lang.Integer((int)1);
var1.ensureCapacity((int)var15);
int var17 = var1.size();
java.lang.Object var18 = null;
boolean var19 = var1.removeElement((java.lang.Object)var18);
int var20 = var1.capacity();
java.lang.Integer var21 = new java.lang.Integer((int)0);
java.lang.Integer var22 = new java.lang.Integer((int)0);
java2.util2.Vector var23 = new java2.util2.Vector((int)var22);
java.lang.Object var24 = null;
var23.addElement((java.lang.Object)var24);
java.lang.Integer var26 = new java.lang.Integer((int)0);
java2.util2.Vector var27 = new java2.util2.Vector((int)var26);
var23.addElement((java.lang.Object)var27);
java.lang.Integer var29 = new java.lang.Integer((int)0);
java2.util2.Vector var30 = new java2.util2.Vector((int)var29);
java.lang.Integer var31 = new java.lang.Integer((int)0);
java.lang.Double var32 = new java.lang.Double((double)10.0);
var30.add((int)var31, (java.lang.Object)var32);
java2.util2.Enumeration var34 = var30.elements();
java.lang.Integer var35 = new java.lang.Integer((int)0);
var23.insertElementAt((java.lang.Object)var34, (int)var35);
java.lang.Integer var37 = new java.lang.Integer((int)1);
var23.ensureCapacity((int)var37);
int var39 = var23.size();
java.lang.Object var40 = null;
boolean var41 = var23.removeElement((java.lang.Object)var40);
boolean var42 = var1.addAll((int)var21, (java2.util2.Collection)var23);

Variables: [var21:[0]]
      /**
       * Inserts all of the elements in in the specified Collection into this
       * Vector at the specified position.  Shifts the element currently at
       * that position (if any) and any subsequent elements to the right
       * (increases their indices).  The new elements will appear in the Vector  
       * in the order that they are returned by the specified Collection's
       * iterator.
       *
       * @param index index at which to insert first element
       *		    from the specified collection.
       * @param c elements to be inserted into this Vector.
       * @return <tt>true</tt> if this Vector changed as a result of the call.
       * @exception ArrayIndexOutOfBoundsException index out of range (index
       *		  &lt; 0 || index &gt; size()).
       * @throws NullPointerException if the specified collection is null.
       * @since 1.2
       */
      public synchronized boolean addAll(int index, Collection c) {
  	modCount++;
  	if (index < 0 || index > elementCount)
  	    throw new ArrayIndexOutOfBoundsException(index);
  
          Object[] a = c.toArray();
  	int numNew = a.length;
  	ensureCapacityHelper(elementCount + numNew);
  
  	int numMoved = elementCount - index;
>>	if (numMoved > 0)
  	    System.arraycopy(elementData, index, elementData, index + numNew,
  			     numMoved);
  
          System.arraycopy(a, 0, elementData, index, numNew);
  	elementCount += numNew;
  	return numNew != 0;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Vector,methodname=addAll,line=908,id=35,direction=false
WILL TRY REPLACING var21 WITH VALUE 0
WILL TRY NEGATING var21
WILL TRY SETTING TO ZERO var21
WILL TRY ADDING 1 var21
WILL TRY SUBTRACTING 1 var21
FAILURE

    // I claim that this branch is unreachable because if (unitsInUse
    // > minUnitsInUse), then the bitsets will always differ, and we
    // won't ever faill out of the for-loop.

START RECORD
BRANCH 
classname=java2.util2.BitSet,methodname=equals,line=955,id=90,direction=true
SEQUENCE
var0 =  cons : java2.util2.BitSet.<init>() : 
var1 =  prim : int:10 : 
var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
var3 =  prim : int:0 : 
var4 =  prim : int:10 : 
var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
var6 =  prim : int:0 : 
var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
var8 =  prim : int:0 : 
var9 =  prim : int:10 : 
var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
var11 =  prim : int:0 : 
var12 =  prim : int:100 : 
var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
var14 =  prim : int:1 : 
var15 =  method : java2.util2.BitSet.set(int) : var10 var14 
var16 =  cons : java2.util2.BitSet.<init>() : 
var17 =  prim : int:10 : 
var18 =  method : java2.util2.BitSet.flip(int) : var16 var17 
var19 =  method : java2.util2.BitSet.xor(java2.util2.BitSet) : var10 var16 
var20 =  cons : java2.util2.BitSet.<init>() : 
var21 =  method : java2.util2.BitSet.equals(java.lang.Object) : var10 var20 

END RECORD

As source code:
java2.util2.BitSet var0 = new java2.util2.BitSet();
java.lang.Integer var1 = new java.lang.Integer((int)10);
var0.flip((int)var1);
java.lang.Integer var3 = new java.lang.Integer((int)0);
java.lang.Integer var4 = new java.lang.Integer((int)10);
var0.flip((int)var3, (int)var4);
java.lang.Integer var6 = new java.lang.Integer((int)0);
var0.clear((int)var6);
java.lang.Integer var8 = new java.lang.Integer((int)0);
java.lang.Integer var9 = new java.lang.Integer((int)10);
java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
java.lang.Integer var11 = new java.lang.Integer((int)0);
java.lang.Integer var12 = new java.lang.Integer((int)100);
var10.flip((int)var11, (int)var12);
java.lang.Integer var14 = new java.lang.Integer((int)1);
var10.set((int)var14);
java2.util2.BitSet var16 = new java2.util2.BitSet();
java.lang.Integer var17 = new java.lang.Integer((int)10);
var16.flip((int)var17);
var10.xor((java2.util2.BitSet)var16);
java2.util2.BitSet var20 = new java2.util2.BitSet();
boolean var21 = var10.equals((java.lang.Object)var20);

Variables: [var12:[2]]
      /**
       * Compares this object against the specified object.
       * The result is <code>true</code> if and only if the argument is 
       * not <code>null</code> and is a <code>Bitset</code> object that has 
       * exactly the same set of bits set to <code>true</code> as this bit 
       * set. That is, for every nonnegative <code>int</code> index <code>k</code>, 
       * <pre>((BitSet)obj).get(k) == this.get(k)</pre>
       * must be true. The current sizes of the two bit sets are not compared. 
       * <p>Overrides the <code>equals</code> method of <code>Object</code>.
       *
       * @param   obj   the object to compare with.
       * @return  <code>true</code> if the objects are the same;
       *          <code>false</code> otherwise.
       * @see     java2.util2.BitSet#size()
       */
      public boolean equals(Object obj) {
  	if (!(obj instanceof BitSet))
  	    return false;
  	if (this == obj)
  	    return true;
  
  	BitSet set = (BitSet) obj;
  	int minUnitsInUse = Math.min(unitsInUse, set.unitsInUse);
  
  	// Check units in use by both BitSets
  	for (int i = 0; i < minUnitsInUse; i++)
  	    if (bits[i] != set.bits[i])
  		return false;
  
  	// Check any units in use by only one BitSet (must be 0 in other)
  	if (unitsInUse > minUnitsInUse) {
>>	    for (int i = minUnitsInUse; i<unitsInUse; i++)
  		if (bits[i] != 0)
  		    return false;
  	} else {
  	    for (int i = minUnitsInUse; i<set.unitsInUse; i++)
  		if (set.bits[i] != 0)
  		    return false;
  	}
  
  	return true;
      }


GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=955,id=90,direction=false
WILL TRY REPLACING var12 WITH VALUE 2
WILL TRY NEGATING var12
WILL TRY SETTING TO ZERO var12
WILL TRY ADDING 1 var12
WILL TRY SUBTRACTING 1 var12
FAILURE
